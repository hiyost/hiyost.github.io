<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yost.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="讲师：林沐 配合视频食用更佳哦！B站链接：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av36288901 1、链表206. 反转链表题目 反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL  进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode课程记录（讲师：林沐）">
<meta property="og:url" content="http://yost.top/2019/12/04/linmu-leetcode/index.html">
<meta property="og:site_name" content="yost">
<meta property="og:description" content="讲师：林沐 配合视频食用更佳哦！B站链接：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av36288901 1、链表206. 反转链表题目 反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL  进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="http://yost.top/2019/12/04/linmu-leetcode/142.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png">
<meta property="article:published_time" content="2019-12-04T09:06:01.000Z">
<meta property="article:modified_time" content="2020-05-20T12:15:35.274Z">
<meta property="article:author" content="yost">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">

<link rel="canonical" href="http://yost.top/2019/12/04/linmu-leetcode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode课程记录（讲师：林沐） | yost</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yost</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yost.top/2019/12/04/linmu-leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yost">
      <meta itemprop="description" content="种一棵树最好的时间是十年前，其次是现在~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yost">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode课程记录（讲师：林沐）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-04 17:06:01" itemprop="dateCreated datePublished" datetime="2019-12-04T17:06:01+08:00">2019-12-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>48 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>讲师：林沐</p>
<p>配合视频食用更佳哦！B站链接：<a href="https://www.bilibili.com/video/av36288901" target="_blank" rel="noopener">https://www.bilibili.com/video/av36288901</a></p>
<h2 id="1、链表"><a href="#1、链表" class="headerlink" title="1、链表"></a>1、链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h3><p><strong>题目</strong></p>
<p>反转一个单链表。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<a id="more"></a>

<p><strong>题解</strong></p>
<p>简单地翻转</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmp := head.Next</span><br><span class="line">        head.Next = pre</span><br><span class="line">        pre = head</span><br><span class="line">        head = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h3><p><strong>题目</strong></p>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>先找到m所在的位置，然后进行反转，注意要对m=1的情况进行特殊处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    pre, cur, i := &amp;ListNode&#123;Next: head&#125;, head, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; m &amp;&amp; cur != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要反转的部分的尾巴</span></span><br><span class="line">    tail, nHead := cur, pre</span><br><span class="line">    <span class="keyword">for</span> ; i &lt;= n &amp;&amp; cur != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">        tmp := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    nHead.Next, tail.Next = pre, cur</span><br><span class="line">    <span class="comment">// 对于 m = 1的情况，head已经被翻转，这时应该返回nHead.Next</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nHead.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h3><p><strong>题目</strong></p>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p>
<p>在节点 c1 开始相交。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">2</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">2</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br></pre></td></tr></table></figure>


<p>示例 3：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">null</span></span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。由于这两个链表不相交，所以 <span class="built_in">int</span>ersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 <span class="literal">null</span>。</span><br></pre></td></tr></table></figure>


<p>注意：</p>
<ul>
<li><p>如果两个链表没有交点，返回 null.</p>
</li>
<li><p>在返回结果后，两个链表仍须保持原有的结构。</p>
</li>
<li><p>可假定整个链表结构中没有循环。</p>
</li>
<li><p>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
</li>
</ul>
<p><strong>题解</strong></p>
<p>先计算两个链表的长度，然后计算将其对齐，再同时移动直到找到交点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先计算两个链表的长度</span></span><br><span class="line">    lenghtA, lenghtB := calculateLength(headA), calculateLength(headB)</span><br><span class="line">    <span class="comment">// 保证B是较长的那个链表</span></span><br><span class="line">    <span class="keyword">if</span> lenghtA &gt; lenghtB &#123;</span><br><span class="line">        lenghtA, lenghtB, headA, headB = lenghtB, lenghtA, headB, headA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将A和B两个链表对齐</span></span><br><span class="line">    <span class="keyword">for</span> ; lenghtB - lenghtA &gt; <span class="number">0</span>; lenghtB, headB = lenghtB <span class="number">-1</span>, headB.Next &#123;&#125;</span><br><span class="line">    <span class="comment">// 同时将AB链表往后移动，知道遇到同一个节点</span></span><br><span class="line">    <span class="keyword">for</span> ; lenghtB &gt; <span class="number">0</span> &amp;&amp; headA != headB;  lenghtB, headB, headA = lenghtB <span class="number">-1</span>, headB.Next, headA.Next &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> headA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateLength</span><span class="params">(head *ListNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; head != <span class="literal">nil</span>; head, n = head.Next, n+<span class="number">1</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h3><p><strong>题目</strong></p>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p>示例 3：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p><strong>题解</strong></p>
<p>使用快慢双指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    pre := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    <span class="keyword">for</span> fast, slow := head, pre; slow != <span class="literal">nil</span> &amp;&amp; fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span>; slow, fast = slow.Next, fast.Next.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h3><p><strong>题目</strong></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：tail connects to node index <span class="number">1</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：tail connects to node index <span class="number">0</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p>示例 3：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>进阶：<br>你是否可以不用额外空间解决此题？</p>
<p><strong>题解</strong></p>
<p>相比于141多了个寻找交点的地方，这个过程可以使用数学的方法证明交点的位置位于在找到meet点之后head和meet点的相遇位置：</p>
<p><img src="/2019/12/04/linmu-leetcode/142.png" alt="142"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    start := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> fast, slow := head, head; slow != <span class="literal">nil</span> &amp;&amp; fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span>; slow, fast = slow.Next, fast.Next.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> !start &amp;&amp; fast == slow &#123;</span><br><span class="line">            <span class="comment">// 找到交点</span></span><br><span class="line">            <span class="keyword">for</span> ; fast != head; fast, head = fast.Next, head.Next &#123;&#125;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        start = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a></h3><p><strong>题目</strong></p>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>, x = <span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>





<p><strong>题解</strong></p>
<p>使用两个head来处理分隔的左右两边的链表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(head *ListNode, x <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    left, right := &amp;ListNode&#123;&#125;, &amp;ListNode&#123;&#125;</span><br><span class="line">    leftHead, rightHead := left, right</span><br><span class="line">    <span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> head.Val &lt; x &#123;</span><br><span class="line">            left.Next = head</span><br><span class="line">            left = head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.Next = head</span><br><span class="line">            right = head</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left.Next = rightHead.Next</span><br><span class="line">    right.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> leftHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h3><p><strong>题目</strong></p>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>递归完成，每次找最小的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1.Val &gt; l2.Val &#123;</span><br><span class="line">        l1, l2 = l2, l1</span><br><span class="line">    &#125;</span><br><span class="line">    l1.Next = mergeTwoLists(l1.Next, l2)</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h3><p><strong>题目</strong></p>
<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>这个题目首先可以使用暴力的方法求解，也就是每次遍历每个链表，取其中最小的那个，只不过这样到后面很多链表都取完了，一个循环里面每个链表还是会遍历一遍，浪费时间。更好的方式是通过归并排序，也就是二分的思路，将n个链表分成二叉树两两归并。</p>
<ul>
<li><p>暴力解法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 一个迭代里面只处理一个最小的node，然后递归</span></span><br><span class="line">    minVal, index :=  <span class="number">65535</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &amp;&amp; list.Val &lt; minVal &#123;</span><br><span class="line">            minVal = list.Val</span><br><span class="line">            index = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> minVal == <span class="number">65535</span> &amp;&amp; index == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    head := lists[index]</span><br><span class="line">    lists[index] = lists[index].Next</span><br><span class="line">    head.Next = mergeKLists(lists)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>归并排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeKLists([]*ListNode&#123;mergeKLists(lists[:n/<span class="number">2</span>]), mergeKLists(lists[n/<span class="number">2</span>:])&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> lists[<span class="number">0</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lists[<span class="number">1</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        a, b := lists[<span class="number">0</span>], lists[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> a.Val &gt; b.Val &#123;</span><br><span class="line">            a, b = lists[<span class="number">1</span>], lists[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证cur永远是比b更小的node</span></span><br><span class="line">        cur := a</span><br><span class="line">        <span class="keyword">for</span> ; cur.Next != <span class="literal">nil</span>; cur = cur.Next &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Next.Val &gt; b.Val &#123;</span><br><span class="line">                cur.Next, b = b, cur.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.Next = b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="2、栈、队列和堆"><a href="#2、栈、队列和堆" class="headerlink" title="2、栈、队列和堆"></a>2、栈、队列和堆</h2><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></h3><p>太简单，不解答了</p>
<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h3><p>太简单，不解答了</p>
<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h3><p>太简单，不解答了（双栈）</p>
<h3 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器*"></a><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a>*</h3><p>了解一下使用双栈的解法</p>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h3><p><strong>题目</strong></p>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<p><strong>题解</strong></p>
<p>方法一：</p>
<p>一种经典的解法是使用堆，维护一个元素个数为k的最小堆，最后只需要返回堆的head就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用最大堆(每一个根节点比叶子节点都要大)来实现</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/heap"</span></span><br><span class="line"><span class="keyword">type</span> maxHeap []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m maxHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(m) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m maxHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> m[i] &lt; m[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *maxHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; (*m)[i], (*m)[j] = (*m)[j], (*m)[i]&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *maxHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	(*m) = <span class="built_in">append</span>((*m), x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *maxHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*m)</span><br><span class="line">	x := (*m)[n<span class="number">-1</span>]</span><br><span class="line">	(*m) = (*m)[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m maxHeap)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> m[<span class="number">0</span>] &#125;</span><br><span class="line"><span class="comment">// 用来确定maxHeap实现了heap.Interface（包含Len、Less、Swap、Push、Pop5个函数）</span></span><br><span class="line"><span class="keyword">var</span> _ = heap.Interface(&amp;maxHeap&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	h := maxHeap&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> h.Len() &lt; k || num &gt;= h.Top() &#123;</span><br><span class="line">			heap.Push(&amp;h, num)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> h.Len() &gt; k &#123;</span><br><span class="line">			heap.Pop(&amp;h)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></h3><p><strong>题目</strong></p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li><p><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中。</p>
</li>
<li><p><code>double findMedian()</code> - 返回目前所有元素的中位数。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addNum</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addNum</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">findMedian</span><span class="params">()</span></span> -&gt; <span class="number">1.5</span></span><br><span class="line"><span class="function"><span class="title">addNum</span><span class="params">(<span class="number">3</span>)</span></span> </span><br><span class="line"><span class="function"><span class="title">findMedian</span><span class="params">()</span></span> -&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p>进阶:</p>
<ol>
<li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
<li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
</ol>
<p><strong>题解</strong></p>
<p>同时使用大小堆来实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minHeap实现小堆（根节点均比叶子节点小）</span></span><br><span class="line"><span class="keyword">type</span> minHeap []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m minHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(m) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m minHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> m[i] &lt; m[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; (*m)[i], (*m)[j] = (*m)[j], (*m)[i]&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	(*m) = <span class="built_in">append</span>((*m), x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *minHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*m)</span><br><span class="line">	x := (*m)[n<span class="number">-1</span>]</span><br><span class="line">	(*m) = (*m)[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m minHeap)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.Len() == <span class="number">0</span> &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> m[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ = heap.Interface(&amp;minHeap&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxHeap实现大堆（根节点均比叶子节点大）</span></span><br><span class="line"><span class="keyword">type</span> maxHeap []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m maxHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(m) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m maxHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> m[i] &gt; m[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *maxHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; (*m)[i], (*m)[j] = (*m)[j], (*m)[i]&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *maxHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	(*m) = <span class="built_in">append</span>((*m), x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *maxHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*m)</span><br><span class="line">	x := (*m)[n<span class="number">-1</span>]</span><br><span class="line">	(*m) = (*m)[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m maxHeap)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.Len() == <span class="number">0</span> &#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> m[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ = heap.Interface(&amp;maxHeap&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">	left maxHeap</span><br><span class="line">	right minHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MedianFinder</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">		left: maxHeap&#123;&#125;,</span><br><span class="line">		right: minHeap&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span> <span class="title">AddNum</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> num &gt;= this.right.Top() &#123;</span><br><span class="line">		heap.Push(&amp;this.right, num)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		heap.Push(&amp;this.left, num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> this.right.Len() == this.left.Len() + <span class="number">2</span> &#123;</span><br><span class="line">		num = heap.Pop(&amp;this.right).(<span class="keyword">int</span>)</span><br><span class="line">		heap.Push(&amp;this.left,num)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> this.right.Len() + <span class="number">2</span> == this.left.Len() &#123;</span><br><span class="line">		num = heap.Pop(&amp;this.left).(<span class="keyword">int</span>)</span><br><span class="line">		heap.Push(&amp;this.right, num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span> <span class="title">FindMedian</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.right.Len() &gt; this.left.Len() &#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="keyword">float64</span>(this.right.Top())</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> this.right.Len() &lt; this.left.Len() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(this.left.Top())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">float64</span>(this.right.Top() + this.left.Top()))/<span class="number">2.0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	obj := Constructor()</span></span><br><span class="line"><span class="comment">	obj.AddNum(1)</span></span><br><span class="line"><span class="comment">	fmt.Println(obj.FindMedian())</span></span><br><span class="line"><span class="comment">	obj.AddNum(2)</span></span><br><span class="line"><span class="comment">	fmt.Println(obj.FindMedian())</span></span><br><span class="line"><span class="comment">	obj.AddNum(3)</span></span><br><span class="line"><span class="comment">	fmt.Println(obj.FindMedian())</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h2 id="3、贪心算法"><a href="#3、贪心算法" class="headerlink" title="3、贪心算法"></a>3、贪心算法</h2><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h3><p><strong>题目</strong></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>注意：</p>
<p>你可以假设胃口值为正。<br>一个小朋友最多只能拥有一块饼干。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，<span class="number">3</span>个孩子的胃口值分别是：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是<span class="number">1</span>，你只能让胃口值是<span class="number">1</span>的孩子满足。</span><br><span class="line">所以你应该输出<span class="number">1</span>。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，<span class="number">2</span>个孩子的胃口值分别是<span class="number">1</span>,<span class="number">2</span>。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出<span class="number">2.</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>先将g和s均排序，然后每次取剩下的最小的饼干，看是否满足还未分配的胃口最小的孩子，不满足则继续取更大的饼干，满足则计数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="keyword">int</span>, s []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    gLen, sLen, i, j := <span class="built_in">len</span>(g), <span class="built_in">len</span>(s), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; gLen &amp;&amp; j &lt; sLen &#123;</span><br><span class="line">        <span class="comment">// s[j]满足分发给g[i]时，递增i即可</span></span><br><span class="line">        <span class="keyword">if</span> s[j] &gt;= g[i] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无论是否满足都要递增j（每个饼干尝试一次）</span></span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h3><p><strong>题目</strong></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">17</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 这个序列包含几个长度为 <span class="number">7</span> 摆动序列，其中一个可为[<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">16</span>,<span class="number">8</span>]。</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p><strong>进阶:</strong><br>你能否用 O(n) 时间复杂度完成此题?</p>
<p><strong>题解</strong></p>
<p>一个变量记录当前变化方向，变化方向发生变化时计数加1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// result保存结果，up保存当前的变化方向，true为上升，false为下降</span></span><br><span class="line">    result, up := <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="comment">// 相等时直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> nums[i+<span class="number">1</span>] == nums[i] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次有变化方向时用up记录</span></span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">1</span> &#123;</span><br><span class="line">            up, result = nums[i+<span class="number">1</span>] &gt; nums[i], result+<span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &gt; nums[i]) != up &#123;</span><br><span class="line">            result++</span><br><span class="line">            up = nums[i+<span class="number">1</span>] &gt; nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></h3><p><strong>题目</strong></p>
<p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<ul>
<li><p>num 的长度小于 10002 且 ≥ k。</p>
</li>
<li><p>num 不会包含任何前导零。</p>
</li>
</ul>
<p>示例 1 :</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = <span class="string">"1432219"</span>, k = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"1219"</span></span><br><span class="line">解释: 移除掉三个数字 <span class="number">4</span>, <span class="number">3</span>, 和 <span class="number">2</span> 形成一个新的最小的数字 <span class="number">1219</span>。</span><br></pre></td></tr></table></figure>


<p>示例 2 :</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="string">"10200"</span>, <span class="attr">k</span> = <span class="number">1</span></span><br><span class="line">输出: <span class="string">"200"</span></span><br><span class="line">解释: 移掉首位的 <span class="number">1</span> 剩下的数字为 <span class="number">200</span>. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>


<p>示例 3 :</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">num</span> = <span class="string">"10"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出: <span class="string">"0"</span></span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是<span class="number">0</span>。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>使用单调递增栈来处理，最小的结果中每一位数字一定是单调递增的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeKdigits</span><span class="params">(num <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    result, n := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>), <span class="built_in">len</span>(num)</span><br><span class="line">    <span class="keyword">if</span> k &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// result栈顶大于当前需要入栈的值时，将栈中大于该值的元素根据k出栈</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(result) &gt; <span class="number">0</span> &amp;&amp; num[i] &lt; result[<span class="built_in">len</span>(result)<span class="number">-1</span>] &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = result[:<span class="built_in">len</span>(result)<span class="number">-1</span>]</span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前值入栈，当然栈为空时不能将0入栈</span></span><br><span class="line">        <span class="keyword">if</span> !(<span class="built_in">len</span>(result) == <span class="number">0</span> &amp;&amp; num[i] == <span class="string">'0'</span> &amp;&amp; i &lt; n<span class="number">-1</span>) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, num[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(result[:<span class="built_in">len</span>(result)-k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h3><p><strong>题目</strong></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 无论怎样，你总会到达索引为 <span class="number">3</span> 的位置。但该位置的最大跳跃长度是 <span class="number">0</span> ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>从后往前遍历，每次更新最前面的跳跃点，其实跳跃游戏2更能体现贪心</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    last := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums)<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> i+nums[i] &gt;= last &amp;&amp; i &lt; last &#123;</span><br><span class="line">            last = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> last == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h3><p><strong>题目</strong></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 <span class="number">2</span>。</span><br><span class="line">     从下标为 <span class="number">0</span> 跳到下标为 <span class="number">1</span> 的位置，跳 <span class="number">1</span> 步，然后跳 <span class="number">3</span> 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<p><strong>题解</strong></p>
<p>贪心，每次跳跃到自己的范围内下次能跳到达的最远的那个点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    cur, n, step := <span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> cur + nums[cur] &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">// 贪心，每次跳跃到自己的范围内下次能跳到达的最远的那个点</span></span><br><span class="line">		max, next := cur, cur</span><br><span class="line">		<span class="keyword">for</span> i:=cur+<span class="number">1</span>; i &lt;= cur + nums[cur]; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i + nums[i] &gt; max &#123;</span><br><span class="line">				max, next = i + nums[i], i</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur, step = next, step + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></h3><p><strong>题目</strong></p>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p>
<p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>Example:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[<span class="number">10</span>,<span class="number">16</span>], [<span class="number">2</span>,<span class="number">8</span>], [<span class="number">1</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x = <span class="number">6</span>（射爆[<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>]两个气球）和 x = <span class="number">11</span>（射爆另外两个气球）。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>先排序，后遍历每一个区间，当重叠区间已经无法满足后面的区间时新增一杆枪</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> array [][]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a array)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a array)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i][<span class="number">0</span>] &lt; a[j][<span class="number">0</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a array)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; a[i][<span class="number">0</span>], a[i][<span class="number">1</span>], a[j][<span class="number">0</span>], a[j][<span class="number">1</span>] = a[j][<span class="number">0</span>], a[j][<span class="number">1</span>], a[i][<span class="number">0</span>], a[i][<span class="number">1</span>] &#125;</span><br><span class="line"><span class="keyword">var</span> _ = sort.Interface(array&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(points) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(points)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(array(points))</span><br><span class="line">    <span class="comment">// curR记录的是当前射击区间的右边界</span></span><br><span class="line">	curR, step := points[<span class="number">0</span>][<span class="number">1</span>], <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> points[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> v[<span class="number">0</span>] &lt;= curR &#123;</span><br><span class="line">            <span class="comment">// 当前区间的右区间变小时更新右区间</span></span><br><span class="line">            <span class="keyword">if</span> v[<span class="number">1</span>] &lt; curR &#123;</span><br><span class="line">                curR = v[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 当前区间无法满足时加一杆枪并更新右区间</span></span><br><span class="line">		curR, step = v[<span class="number">1</span>], step+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4、递归、回溯与分治"><a href="#4、递归、回溯与分治" class="headerlink" title="4、递归、回溯与分治"></a>4、递归、回溯与分治</h2><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h3><p><strong>题目</strong></p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>使用递归的方式，先算出子集的所有子集，然后遍历添加</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    n, result := <span class="built_in">len</span>(nums), [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> subsets(nums[<span class="number">1</span>:]) &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, v)</span><br><span class="line">        result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;nums[<span class="number">0</span>]&#125;, v...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h3><p><strong>题目</strong></p>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<p><strong>题解</strong></p>
<p>相比于子集I，这个题目中输入的数组可能会重复，因此需要去重，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsetsWithDup</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先排序，以便将相等的放在一起</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">	<span class="keyword">return</span> subsets(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	n, result := <span class="built_in">len</span>(nums), [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> subsets(nums[<span class="number">1</span>:]) &#123;</span><br><span class="line">        <span class="comment">// 如果nums[0] == nums[1] == v[0]，那么就不要append v，因为subsets(nums[1:])中肯定也有v[1:]了，后面append([]int&#123;nums[0]&#125;, v...)会与之重复</span></span><br><span class="line">		<span class="keyword">if</span> !( n&gt;<span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == nums[<span class="number">1</span>] &amp;&amp; <span class="built_in">len</span>(v) &gt; <span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == v[<span class="number">0</span>]) &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, v)</span><br><span class="line">		&#125;</span><br><span class="line">		result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;nums[<span class="number">0</span>]&#125;, v...))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h3><p><strong>题目</strong></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<ul>
<li><p>所有数字（包括 target）都是正整数。</p>
</li>
<li><p>解集不能包含重复的组合。 </p>
</li>
</ul>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>通过递归遍历剪枝实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> target &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result, n := [][]<span class="keyword">int</span>&#123;&#125;, <span class="built_in">len</span>(candidates)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果当前数字就能满足要求，就直接加入result中</span></span><br><span class="line">        <span class="keyword">if</span> target == candidates[i] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;candidates[i]&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前的数字与后面的候选数组中能组合出target，则也加入result中</span></span><br><span class="line">        <span class="comment">// 这里使用candidates[i:]是因为当前数字是可以重复的</span></span><br><span class="line">        <span class="keyword">if</span> can := combinationSum(candidates[i:], target-candidates[i]); <span class="built_in">len</span>(can) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, v := <span class="keyword">range</span> can &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;candidates[i]&#125;, v...))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h3><p><strong>题目</strong></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>由于这题的条件中所给的数组中元素是可以重复的，因此要先做个排序，然后逻辑复用39.组合总和就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(candidates)</span><br><span class="line">    <span class="keyword">return</span> combinationSum(candidates, target)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> target &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result, n := [][]<span class="keyword">int</span>&#123;&#125;, <span class="built_in">len</span>(candidates)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="comment">// 如果当前的数字是重复数字则跳过</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前数字就能满足要求，就直接加入result中</span></span><br><span class="line">        <span class="keyword">if</span> target == candidates[i] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;candidates[i]&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前的数字与后面的候选数组中能组合出target，则也加入result中</span></span><br><span class="line">        <span class="comment">// 这里使用candidates[i+1:]是因为当前数字是不能重复的</span></span><br><span class="line">        <span class="keyword">if</span> can := combinationSum(candidates[i+<span class="number">1</span>:], target-candidates[i]); <span class="built_in">len</span>(can) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _, v := <span class="keyword">range</span> can &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;candidates[i]&#125;, v...))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h3><p><strong>题目</strong></p>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>通过递归实现，每次可以选择增加一个左括号或者右括号，通过计数器来判断是否是满足条件的，满足条件时加入到结果中。注意因为要append到slice中，需要使用slice指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    generate(n, <span class="number">0</span>, <span class="string">""</span>, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(n, left <span class="keyword">int</span>, item <span class="keyword">string</span>, result *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(item) == <span class="number">2</span>*n &#123;</span><br><span class="line">        *result = <span class="built_in">append</span>(*result, item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &lt; <span class="number">0</span> || left &gt; n || <span class="built_in">len</span>(item) &gt; <span class="number">2</span>*n &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &lt; n &#123;</span><br><span class="line">        generate(n, left+<span class="number">1</span>, item+<span class="string">"("</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &gt; <span class="number">0</span> &#123;</span><br><span class="line">        generate(n, left<span class="number">-1</span>, item+<span class="string">")"</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></h3><p><strong>题目</strong></p>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt="img"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 4</span></span><br><span class="line"><span class="section">输出: [</span></span><br><span class="line"> [<span class="string">".Q.."</span>,  // 解法 1</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // 解法 2</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line"><span class="section">解释: 4 皇后问题存在两个不同的解法。</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>dfs，每次在新行加入一个Q之后，查找这个Q导致需要变成’.’的点，dfs完成之后恢复这些点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">	ret := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	board := [][]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		board = <span class="built_in">append</span>(board, <span class="built_in">make</span>([]<span class="keyword">byte</span>, n))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第一行的Q所在的位置</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		ret = dfs(<span class="number">0</span>, i, board, ret)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(i, j <span class="keyword">int</span>, board [][]<span class="keyword">byte</span>, ret [][]<span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">	board[i][j] = <span class="string">'Q'</span></span><br><span class="line">	<span class="comment">// 当前已经到达最后一行则说明满足要求并记录到最终的结果中</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(board)<span class="number">-1</span> &#123;</span><br><span class="line">		s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(board))</span><br><span class="line">		<span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;<span class="built_in">len</span>(board); x++ &#123;</span><br><span class="line">			s[x] = <span class="keyword">string</span>(board[x])</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">		board[i][j] = <span class="string">' '</span></span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">	cur := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 找到当前需要去掉的点并记录下来，方便后面恢复</span></span><br><span class="line">	<span class="keyword">for</span> x:=i; x&lt;<span class="built_in">len</span>(board); x++&#123;</span><br><span class="line">		<span class="keyword">for</span> y:=<span class="number">0</span>; y&lt;<span class="built_in">len</span>(board); y++&#123;</span><br><span class="line">			<span class="keyword">if</span> board[x][y] != <span class="string">'.'</span> &amp;&amp; board[x][y] != <span class="string">'Q'</span> &amp;&amp; (x == i || y == j || x-y == i-j || x+y == i+j) &#123;</span><br><span class="line">				cur=<span class="built_in">append</span>(cur, []<span class="keyword">int</span>&#123;x, y&#125;)</span><br><span class="line">				board[x][y] = <span class="string">'.'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> y:=<span class="number">0</span>; y&lt;<span class="built_in">len</span>(board); y++ &#123;</span><br><span class="line">		<span class="keyword">if</span> board[i+<span class="number">1</span>][y] != <span class="string">'.'</span> &#123;</span><br><span class="line">			ret = dfs(i+<span class="number">1</span>, y, board, ret)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 恢复当前去掉的点并去掉Q</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> cur &#123;</span><br><span class="line">		board[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	board[i][j] = <span class="string">' '</span></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></h3><p><strong>题目</strong></p>
<p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>] </span><br><span class="line">解释:</span><br><span class="line"><span class="number">5</span> 的右侧有 <span class="number">2</span> 个更小的元素 (<span class="number">2</span> 和 <span class="number">1</span>).</span><br><span class="line"><span class="number">2</span> 的右侧仅有 <span class="number">1</span> 个更小的元素 (<span class="number">1</span>).</span><br><span class="line"><span class="number">6</span> 的右侧有 <span class="number">1</span> 个更小的元素 (<span class="number">1</span>).</span><br><span class="line"><span class="number">1</span> 的右侧有 <span class="number">0</span> 个更小的元素.</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>方法一（归并排序）：</p>
<p>利用归并排序的思路，从后往前遍历数组，每次将当前元素插入到新建的一个排序好的数组中，插入的位置就是当前这个元素右侧小于该元素的个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    sortedNums, ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, n), <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    count(nums, ret, sortedNums, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(nums, ret, sortedNums []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入之后最后一个（最大）元素的索引</span></span><br><span class="line">    j := <span class="built_in">len</span>(nums) <span class="number">-1</span> - i</span><br><span class="line">    <span class="comment">// 寻找可以插入的位置，其对应的位置的索引就是右侧小于该值的个数</span></span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span>; k &lt; j; k ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> sortedNums[k] &gt;= nums[i] &#123;</span><br><span class="line">            ret[i] = k</span><br><span class="line">            <span class="keyword">for</span> l := j; l &gt; k; l -- &#123;</span><br><span class="line">                sortedNums[l] = sortedNums[l<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            sortedNums[k] = nums[i]</span><br><span class="line">            count(nums, ret, sortedNums, i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到则说明是当前最大的，放在最后</span></span><br><span class="line">    sortedNums[j], ret[i] = nums[i], j</span><br><span class="line">    count(nums, ret, sortedNums, i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（树状数组）：</p>
<p>首先要弄清楚树状数组的概念，树状数组的目的在于更加平衡地进行前缀和的更新和查询（普通的做法中更新的时间复杂度为O(1)，查询的复杂度为O(n)，使用树状数组更新和查询的时间复杂度均为为O(log n)），对于大规模的更新和查询而言，其时间效率是大大提升的。</p>
<h2 id="5、二叉树与图"><a href="#5、二叉树与图" class="headerlink" title="5、二叉树与图"></a>5、二叉树与图</h2><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></h3><p><strong>题目</strong></p>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p><strong>题解</strong></p>
<p>深度优先遍历即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root.Val == sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></h3><p><strong>题目</strong></p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1</code></pre><p>返回:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>深度优先遍历时记录路径即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    sumPath(root, sum, []<span class="keyword">int</span>&#123;&#125;, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumPath</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>, item []<span class="keyword">int</span>, result *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    item = <span class="built_in">append</span>(item, root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sum == root.Val &#123;</span><br><span class="line">            *result = <span class="built_in">append</span>(*result, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, item...))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        sumPath(root.Left, sum - root.Val, item, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        sumPath(root.Right, sum - root.Val, item, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h3><p><strong>题目</strong></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="img"></p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>我的烂算法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for TreeNode.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *ListNode</span></span><br><span class="line"><span class="comment"> *     Right *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">     pPath := findPath(root, p)</span><br><span class="line">     qPath := findPath(root, q)</span><br><span class="line">     i := <span class="number">0</span></span><br><span class="line">     <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(pPath) &amp;&amp; i&lt;<span class="built_in">len</span>(qPath) &amp;&amp; pPath[i] == qPath[i]; i++ &#123;&#125;</span><br><span class="line">     <span class="keyword">return</span> pPath[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到节点到root的路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPath</span><span class="params">(root, node *TreeNode)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || (root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root != node) &#123;</span><br><span class="line">        <span class="keyword">return</span> []*TreeNode&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">if</span> root == node &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> path := findPath(root.Left, node); <span class="built_in">len</span>(path) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">append</span>(result, path...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> path := findPath(root.Right, node); <span class="built_in">len</span>(path) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">append</span>(result, path...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []*TreeNode&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优秀的算法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for TreeNode.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *ListNode</span></span><br><span class="line"><span class="comment"> *     Right *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> root == <span class="literal">nil</span> || p == root || q == root &#123;</span><br><span class="line">         <span class="keyword">return</span> root</span><br><span class="line">     &#125;</span><br><span class="line">     left, right := lowestCommonAncestor(root.Left, p, q), lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">     <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> root</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> left</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> right != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> right</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h3><p><strong>题目</strong></p>
<p>给定一个二叉树，原地将它展开为链表。</p>
<p>例如，给定二叉树</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>


<p>将其展开为：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>将右子树移动到左子树的最右边，然后将左子树移动有右子树的位置，递归遍历即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := root.Left, root.Right</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        flatten(root.Right)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> left.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = left.Right</span><br><span class="line">    &#125;</span><br><span class="line">    left.Right, root.Right = right, root.Left</span><br><span class="line">    root.Left = <span class="literal">nil</span></span><br><span class="line">    flatten(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h3><p><strong>题目</strong></p>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;---</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>通过队列来进行层序遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">type</span> levelNode <span class="keyword">struct</span> &#123;</span><br><span class="line">     node *TreeNode</span><br><span class="line">     level <span class="keyword">int</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result, queue := []<span class="keyword">int</span>&#123;root.Val&#125;, []levelNode&#123;levelNode&#123;node: root, level: <span class="number">1</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        cur := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> cur.level &gt; <span class="built_in">len</span>(result) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, cur.node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// result[cur.level-1]的值最终是这一层最右侧的节点的值</span></span><br><span class="line">        result[cur.level<span class="number">-1</span>] = cur.node.Val</span><br><span class="line">        <span class="keyword">if</span> cur.node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, levelNode&#123;node: cur.node.Left, level: cur.level + <span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cur.node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, levelNode&#123;node: cur.node.Right, level: cur.level + <span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h3><p><strong>题目</strong></p>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span>；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span>。这是不可能的。</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<ol>
<li><p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</p>
</li>
<li><p>你可以假定输入的先决条件中没有重复的边。</p>
</li>
</ol>
<p>提示:</p>
<ol>
<li><p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</p>
</li>
<li><p>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</p>
</li>
</ol>
<p><strong>题解</strong></p>
<p>我的效率较低的算法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    pre, isVisited := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses), <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        pre[v[<span class="number">0</span>]] = <span class="built_in">append</span>(pre[v[<span class="number">0</span>]], v[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(pre)</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> isVisited &#123;</span><br><span class="line">        <span class="comment">// isVisited[i] == 1表明已经搜索过，== 0表示没有搜索过，== -1表示正在处理</span></span><br><span class="line">        <span class="keyword">if</span> isVisited[i] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dfs(i, pre, &amp;isVisited) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(isVisited)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(cur <span class="keyword">int</span>, pre [][]<span class="keyword">int</span>, isVisited *[]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    (*isVisited)[cur] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> pre[cur] &#123;</span><br><span class="line">        <span class="keyword">if</span> (*isVisited)[v] == <span class="number">-1</span> || ((*isVisited)[v] == <span class="number">0</span> &amp;&amp; dfs(v, pre, isVisited)) &#123;</span><br><span class="line">            <span class="comment">// 说明有环，则返回true，其他情况不返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*isVisited)[cur] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  效率最高的算法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    inNums := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    record := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(prerequisites); i++ &#123;</span><br><span class="line">        toLearn, requisite := prerequisites[i][<span class="number">0</span>], prerequisites[i][<span class="number">1</span>]</span><br><span class="line">        inNums[toLearn]++</span><br><span class="line">        record[requisite] = <span class="built_in">append</span>(record[requisite], toLearn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(inNums); &#123;</span><br><span class="line">        <span class="keyword">if</span> inNums[i] == <span class="number">0</span> &#123;</span><br><span class="line">            inNums[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> _, canLearn := <span class="keyword">range</span> record[i] &#123;</span><br><span class="line">                inNums[canLearn]--</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(inNums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> inNums[i] != <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6、二分查找与二叉排序树"><a href="#6、二分查找与二叉排序树" class="headerlink" title="6、二分查找与二叉排序树"></a>6、二分查找与二叉排序树</h2><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h3><p><strong>题目</strong></p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>


<p>示例 4:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>这个题目使用暴力比二分效率更高啊</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> target &gt; nums[right] &#123;</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> target &lt;= nums[left] &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分搜索</span></span><br><span class="line">    <span class="keyword">for</span> right &gt; left+<span class="number">1</span> &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置*"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a>*</h3><h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组*"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a>*</h3><h3 id="315-计算右侧小于当前元素的个数-1"><a href="#315-计算右侧小于当前元素的个数-1" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></h3><p><strong>题目</strong></p>
<p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>] </span><br><span class="line">解释:</span><br><span class="line"><span class="number">5</span> 的右侧有 <span class="number">2</span> 个更小的元素 (<span class="number">2</span> 和 <span class="number">1</span>).</span><br><span class="line"><span class="number">2</span> 的右侧仅有 <span class="number">1</span> 个更小的元素 (<span class="number">1</span>).</span><br><span class="line"><span class="number">6</span> 的右侧有 <span class="number">1</span> 个更小的元素 (<span class="number">1</span>).</span><br><span class="line"><span class="number">1</span> 的右侧有 <span class="number">0</span> 个更小的元素.</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>方法一（归并排序）：</p>
<p>利用归并排序的思路，从后往前遍历数组，每次将当前元素插入到新建的一个排序好的数组中，插入的位置就是当前这个元素右侧小于该元素的个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    sortedNums, ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, n), <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    count(nums, ret, sortedNums, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(nums, ret, sortedNums []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入之后最后一个（最大）元素的索引</span></span><br><span class="line">    j := <span class="built_in">len</span>(nums) <span class="number">-1</span> - i</span><br><span class="line">    <span class="comment">// 寻找可以插入的位置，其对应的位置的索引就是右侧小于该值的个数</span></span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span>; k &lt; j; k ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> sortedNums[k] &gt;= nums[i] &#123;</span><br><span class="line">            ret[i] = k</span><br><span class="line">            <span class="keyword">for</span> l := j; l &gt; k; l -- &#123;</span><br><span class="line">                sortedNums[l] = sortedNums[l<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            sortedNums[k] = nums[i]</span><br><span class="line">            count(nums, ret, sortedNums, i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找不到则说明是当前最大的，放在最后</span></span><br><span class="line">    sortedNums[j], ret[i] = nums[i], j</span><br><span class="line">    count(nums, ret, sortedNums, i<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（树状数组）：</p>
<p>首先要弄清楚树状数组的概念，树状数组的目的在于更加平衡地进行前缀和的更新和查询（普通的做法中更新的时间复杂度为O(1)，查询的复杂度为O(n)，使用树状数组更新和查询的时间复杂度均为为O(log n)），对于大规模的更新和查询而言，其时间效率是大大提升的。</p>
<h2 id="7、哈希表与字符串"><a href="#7、哈希表与字符串" class="headerlink" title="7、哈希表与字符串"></a>7、哈希表与字符串</h2><h3 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a></h3><p><strong>题目</strong></p>
<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line"><span class="string">"abccccdd"</span></span><br><span class="line"></span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">7</span><br><span class="line"></span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">我们可以构造的最长的回文串是<span class="string">"dccaccd"</span>, 它的长度是 7。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>用hash表记录每个字母的个数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    hash, n := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">256</span>), <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        hash[s[i]-<span class="string">'a'</span>] ++</span><br><span class="line">    &#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">        <span class="keyword">if</span> v%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            sum += v</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += v<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum &lt; n &#123;</span><br><span class="line">        sum ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></h3><p><strong>题目</strong></p>
<p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">pattern</span> = <span class="string">"abba"</span>, <span class="attr">str</span> = <span class="string">"dog cat cat dog"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:<span class="attr">pattern</span> = <span class="string">"abba"</span>, <span class="attr">str</span> = <span class="string">"dog cat cat fish"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">pattern</span> = <span class="string">"aaaa"</span>, <span class="attr">str</span> = <span class="string">"dog cat cat dog"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p>示例 4:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">pattern</span> = <span class="string">"abba"</span>, <span class="attr">str</span> = <span class="string">"dog dog dog dog"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<p><strong>说明:</strong><br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    </p>
<p><strong>题解</strong></p>
<p>用两个hash表来建立对应关系</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordPattern</span><span class="params">(pattern <span class="keyword">string</span>, str <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	data := strings.Fields(str)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) != <span class="built_in">len</span>(pattern) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">	b2s, s2b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">string</span>), <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">byte</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> m, ok := b2s[pattern[i]]; ok &#123;</span><br><span class="line">			<span class="keyword">if</span> m != v &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b2s[pattern[i]] = v</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> m, ok := s2b[v]; ok &#123;</span><br><span class="line">			<span class="keyword">if</span> m != pattern[i] &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s2b[v] = pattern[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></h3><p><strong>题目</strong></p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>
<p><strong>题解</strong></p>
<p>注意：由于go语言中是没有自带byte数组的排序，所以需要自行实现排序的interface。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Byte []<span class="keyword">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Byte)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Byte)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> b[i] &lt; b[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Byte)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; b[i], b[j] = b[j], b[i] &#125;</span><br><span class="line"><span class="comment">// 先用hash表来保存字母相同的字符串，然后组合成二维字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        b := Byte(v)</span><br><span class="line">        sort.Sort(b)</span><br><span class="line">        s := <span class="keyword">string</span>(b)</span><br><span class="line">        <span class="keyword">if</span> _, ok := hash[s]; ok &#123;</span><br><span class="line">            hash[s] = <span class="built_in">append</span>(hash[s], v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash[s] = []<span class="keyword">string</span>&#123;v&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h3><p><strong>题目</strong></p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span></span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>左右双指针移动（20ms）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">	left, right, max, n := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">for</span> ; right &lt; n; right++ &#123;</span><br><span class="line">		<span class="comment">// 先移动右指针，直到有一个发生重复</span></span><br><span class="line">		<span class="keyword">for</span> ; ; right++ &#123;</span><br><span class="line">			<span class="keyword">if</span> right == n &#123;</span><br><span class="line">				<span class="keyword">return</span> maximum(max, right - left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> v, ok := hash[s[right]]; ok &#123;</span><br><span class="line">				hash[s[right]]++</span><br><span class="line">				<span class="keyword">if</span> v == <span class="number">1</span> &#123;</span><br><span class="line">					max = maximum(max, right - left)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				hash[s[right]] = <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fmt.Println(s[left:right])</span></span><br><span class="line">		<span class="comment">// 再移动左指针，直到消除这个重复</span></span><br><span class="line">		<span class="keyword">for</span> ; hash[s[right]] &gt; <span class="number">1</span>; left++ &#123;</span><br><span class="line">			hash[s[left]]--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximum</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0ms的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义游标尺寸大小,游标的左边位置</span></span><br><span class="line">    window,start := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环字符串</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="number">0</span>; key &lt; <span class="built_in">len</span>(s); key++ &#123;</span><br><span class="line">        <span class="comment">// 查看当前字符串是否在游标内</span></span><br><span class="line">        isExist := strings.Index(<span class="keyword">string</span>(s[start:key]), <span class="keyword">string</span>(s[key]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果不存在游标内部,游标长度重新计算并赋值</span></span><br><span class="line">        <span class="keyword">if</span> (isExist == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key - start + <span class="number">1</span> &gt; window) &#123;</span><br><span class="line">                window = key - start + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//存在，游标开始位置更换为重复字符串位置的下一个位置</span></span><br><span class="line">            start = start + <span class="number">1</span> + isExist</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a></h3><p><strong>题目</strong></p>
<p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）。</p>
<p>示例：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span></span><br><span class="line">输出：[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>]</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>最简单的方法就是直接使用hash表来记录</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=n<span class="number">-10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := hash[s[i:i+<span class="number">10</span>]]; ok &#123;</span><br><span class="line">            hash[s[i:i+<span class="number">10</span>]]++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash[s[i:i+<span class="number">10</span>]] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">1</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过重新编码来提高查询的效率</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mt := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">byte</span> &#123;</span><br><span class="line">        <span class="string">'A'</span> : <span class="number">0x0</span>,</span><br><span class="line">        <span class="string">'C'</span> : <span class="number">0x1</span>,</span><br><span class="line">        <span class="string">'G'</span> : <span class="number">0x2</span>,</span><br><span class="line">        <span class="string">'T'</span> : <span class="number">0x3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    seen := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span> &lt;&lt; <span class="number">20</span>) <span class="comment">//</span></span><br><span class="line">    ans := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    cur := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">        cur = ((cur &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFFFFF</span>) | <span class="keyword">uint32</span>(mt[s[i]])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">9</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        cur = ((cur &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFFFFF</span>) | <span class="keyword">uint32</span>(mt[s[i]])</span><br><span class="line">        <span class="keyword">if</span> seen[cur] == <span class="number">0</span> &#123;</span><br><span class="line">            seen[cur] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> seen[cur] == <span class="number">1</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, <span class="keyword">string</span>(s[i<span class="number">-9</span>:i+<span class="number">1</span>])) <span class="comment">//</span></span><br><span class="line">            seen[cur] = <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h3><p><strong>题目</strong></p>
<p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p>
<p>示例：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">S</span> = <span class="string">"ADOBECODEBANC"</span>, <span class="attr">T</span> = <span class="string">"ABC"</span></span><br><span class="line">输出: <span class="string">"BANC"</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 “”。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>题解</strong></p>
<p>使用两个指针来进行搜索，从前往后慢慢搜索满足要求的子串，后面的指针用来找到满足要求的子串，前面的指针用来移动到长度最小。注意这里没有用字符比较的方式进行匹配，而是通过一个计数器来判断，具体请看代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    tMap, sMap := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">58</span>), <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">58</span>)</span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> t &#123;</span><br><span class="line">        tMap[i-<span class="string">'A'</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    head, tail, minL, minR := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> fulfill := <span class="number">0</span>; tail &lt; <span class="built_in">len</span>(s); tail++ &#123;</span><br><span class="line">        <span class="comment">// t中不存在这个字符则不用管</span></span><br><span class="line">        <span class="keyword">if</span> tMap[s[tail]-<span class="string">'A'</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        sMap[s[tail]-<span class="string">'A'</span>]++</span><br><span class="line">        <span class="keyword">if</span> sMap[s[tail]-<span class="string">'A'</span>] &lt;= tMap[s[tail]-<span class="string">'A'</span>] &#123;</span><br><span class="line">            <span class="comment">// 字符只有小于或等于t这个字符串中该字符的个数时才产生作用</span></span><br><span class="line">            fulfill++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> fulfill == <span class="built_in">len</span>(t) &#123;</span><br><span class="line">            <span class="comment">// 满足当前要求，则向右移动head，直到遇到第一个使子串不满足要求为止</span></span><br><span class="line">            <span class="comment">// 即s[head:tail+1]满足要求，s[head+1:tail+1]不满足，为当前的最短子串</span></span><br><span class="line">            <span class="keyword">for</span> ;tMap[s[head]-<span class="string">'A'</span>] == <span class="number">0</span> || sMap[s[head]-<span class="string">'A'</span>] &gt; tMap[s[head]-<span class="string">'A'</span>]; head++ &#123;</span><br><span class="line">                <span class="keyword">if</span> tMap[s[head]-<span class="string">'A'</span>] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                    sMap[s[head]-<span class="string">'A'</span>]--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> tail-head &lt; minR-minL &#123;</span><br><span class="line">                 minR, minL = tail,head</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// head右移一位，这样s[head:tail+1]又不满足要求了</span></span><br><span class="line">            sMap[s[head]-<span class="string">'A'</span>]--</span><br><span class="line">            head++</span><br><span class="line">            fulfill--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> minR== <span class="built_in">len</span>(s)+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[minL:minR+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="8、搜索"><a href="#8、搜索" class="headerlink" title="8、搜索"></a>8、搜索</h2><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h3><p><strong>题目</strong></p>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>简单的dfs，每次遇到岛屿的时候把这个岛屿所有的陆地都染色。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> grid &#123;</span><br><span class="line">        <span class="keyword">for</span> j, _ := <span class="keyword">range</span> v &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">                sum ++</span><br><span class="line">                sameIsland(grid, i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sameIsland</span><span class="params">(grid [][]<span class="keyword">byte</span>, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    near := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    grid[i][j] = <span class="string">'2'</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> near &#123;</span><br><span class="line">        <span class="keyword">if</span> i+v[<span class="number">0</span>] &gt;= <span class="built_in">len</span>(grid) || i+v[<span class="number">0</span>] &lt; <span class="number">0</span> || j+v[<span class="number">1</span>] &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || j+v[<span class="number">1</span>]&lt;<span class="number">0</span> || grid[i+v[<span class="number">0</span>]][j+v[<span class="number">1</span>]] != <span class="string">'1'</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        sameIsland(grid, i+v[<span class="number">0</span>], j+v[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></h3><p><strong>题目</strong></p>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p>
<p>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,</span><br><span class="line">     返回它的长度 <span class="number">5</span>。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"></span><br><span class="line"><span class="section">解释: endWord "cog" 不在字典中，所以无法进行转换。</span></span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<p>这题用dfs会超时，所以最好使用bfs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs，会超时</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ladderLength</span><span class="params">(beginWord <span class="keyword">string</span>, endWord <span class="keyword">string</span>, wordList []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(wordList)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> wordList &#123;</span><br><span class="line">        <span class="keyword">if</span> v == endWord &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num := math.MaxInt64</span><br><span class="line">    dfs(beginWord, endWord, <span class="number">1</span>, &amp;num, wordList)</span><br><span class="line">    <span class="keyword">if</span> num == math.MaxInt64 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(beginWord, endWord <span class="keyword">string</span>, step <span class="keyword">int</span>, num *<span class="keyword">int</span>, wordList []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> beginWord == endWord &#123;</span><br><span class="line">        <span class="keyword">if</span> step &lt; *num &#123;</span><br><span class="line">            *num = step</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> wordList &#123;</span><br><span class="line">        <span class="keyword">if</span> canConvert(beginWord, v) &#123;</span><br><span class="line">            list := <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;&#125;, wordList[:i]...)</span><br><span class="line">            list = <span class="built_in">append</span>(list, wordList[i+<span class="number">1</span>:]...)</span><br><span class="line">            dfs(v, endWord, step+<span class="number">1</span>, num, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConvert</span><span class="params">(cur, next <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cur) != <span class="built_in">len</span>(next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum, n := <span class="number">0</span>, <span class="built_in">len</span>(cur)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cur[i] != next[i] &#123;</span><br><span class="line">            sum++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>188ms</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ladderLength</span><span class="params">(beginWord <span class="keyword">string</span>, endWord <span class="keyword">string</span>, wordList []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> beginWord == endWord &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(wordList)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> wordList &#123;</span><br><span class="line">        <span class="keyword">if</span> v == endWord &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> canConvert(wordList[i], wordList[j]) &#123;</span><br><span class="line">                list[i] = <span class="built_in">append</span>(list[i], j)</span><br><span class="line">                list[j] = <span class="built_in">append</span>(list[j], i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num := math.MaxInt64</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> canConvert(beginWord, wordList[i]) &#123;</span><br><span class="line">            bfs(i, wordList, list, &amp;num, endWord)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> num == math.MaxInt64 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(i <span class="keyword">int</span>, wordList []<span class="keyword">string</span>, list [][]<span class="keyword">int</span>, num *<span class="keyword">int</span>, endWord <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> wordList[i] == endWord &#123;</span><br><span class="line">        *num = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    isVisited := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(wordList))</span><br><span class="line">    isVisited[i] = <span class="literal">true</span></span><br><span class="line">    queue := [][]<span class="keyword">int</span>&#123;&#123;i, <span class="number">2</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        cur := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> list[cur[<span class="number">0</span>]] &#123;</span><br><span class="line">            <span class="keyword">if</span> !isVisited[v] &#123;</span><br><span class="line">                <span class="keyword">if</span> wordList[v] == endWord &#123;</span><br><span class="line">                    <span class="keyword">if</span> cur[<span class="number">1</span>]+<span class="number">1</span> &lt; *num &#123;</span><br><span class="line">                        *num = cur[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                isVisited[v] = <span class="literal">true</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, []<span class="keyword">int</span>&#123;v, cur[<span class="number">1</span>]+<span class="number">1</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConvert</span><span class="params">(cur, next <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cur) != <span class="built_in">len</span>(next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum, n := <span class="number">0</span>, <span class="built_in">len</span>(cur)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cur[i] != next[i] &#123;</span><br><span class="line">            sum++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>排名第一的算法16ms</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ladderLength</span><span class="params">(beginWord <span class="keyword">string</span>, endWord <span class="keyword">string</span>, wordList []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	wordDict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, word := <span class="keyword">range</span> wordList &#123;</span><br><span class="line">		wordDict[word] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提前返回</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := wordDict[endWord]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	src, dst := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	src[beginWord] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	dst[endWord] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	found := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	ok := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(src) != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dst) != <span class="number">0</span> &amp;&amp; !found &#123;</span><br><span class="line">		res++</span><br><span class="line">		<span class="comment">// 始终遍历 小数组</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(src) &gt; <span class="built_in">len</span>(dst) &#123;</span><br><span class="line">			src, dst = dst, src</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> w := <span class="keyword">range</span> src &#123;</span><br><span class="line">			<span class="built_in">delete</span>(wordDict, w)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		newSrc := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">for</span> word := <span class="keyword">range</span> src &#123;</span><br><span class="line">			bytes := []<span class="keyword">byte</span>(word) <span class="comment">// 转成 []byte，然后修改值</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bytes); i++ &#123;</span><br><span class="line">				<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">26</span>; j++ &#123;</span><br><span class="line">					bytes[i] = <span class="keyword">byte</span>(j) + <span class="string">'a'</span> <span class="comment">// 修改为 a-z</span></span><br><span class="line">					target := <span class="keyword">string</span>(bytes) <span class="comment">// 转成 string</span></span><br><span class="line">					<span class="keyword">if</span> _, ok = dst[target]; ok &#123; <span class="comment">// 已经连通</span></span><br><span class="line">						<span class="keyword">return</span> res</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> _, ok = wordDict[target]; ok &#123;</span><br><span class="line">							newSrc[target] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 恢复原来的值</span></span><br><span class="line">				bytes[i] = word[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		src = newSrc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向bfs了解一下。</p>
<h3 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II*"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a>*</h3><h3 id="473-火柴拼正方形"><a href="#473-火柴拼正方形" class="headerlink" title="473. 火柴拼正方形"></a><a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">473. 火柴拼正方形</a></h3><p><strong>题目</strong></p>
<p>还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。</p>
<p>输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">解释: 能拼成一个边长为<span class="number">2</span>的正方形，每边两根火柴。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">解释: 不能用所有火柴拼成一个正方形。</span><br></pre></td></tr></table></figure>


<p>注意:</p>
<ul>
<li><p>给定的火柴长度和在 0 到 10^9之间。 </p>
</li>
<li><p>火柴数组的长度不超过15。</p>
</li>
</ul>
<p><strong>题解</strong></p>
<p>可以使用建议的dfs进行深度遍历，遍历之前对其进行排序，从长到短进行遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makesquare</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sum, n := sumOf(nums), <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum%<span class="number">4</span> != <span class="number">0</span> || n &lt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// per保存的是每个边的边长，count保存的是当前每个边已经加入的火柴的总长度</span></span><br><span class="line">    per, count := sum/<span class="number">4</span>, <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">if</span> nums[n<span class="number">-1</span>] &gt; per &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, count, per, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(nums, count []<span class="keyword">int</span>, per, i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j, _ := <span class="keyword">range</span> count &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= per - count[j] &#123;</span><br><span class="line">            count[j] += nums[i]</span><br><span class="line">            <span class="keyword">if</span> dfs(nums, count, per, i<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败后需要回退</span></span><br><span class="line">            count[j] -= nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="407-接雨水-II"><a href="#407-接雨水-II" class="headerlink" title="407. 接雨水 II*"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407. 接雨水 II</a>*</h3><h2 id="9、动态规划"><a href="#9、动态规划" class="headerlink" title="9、动态规划"></a>9、动态规划</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h3><p><strong>题目</strong></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">   </span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 转移方程：d[i] = d[i-1] + d[i-2]</span></span><br><span class="line"><span class="comment">// 也就是d[i]是基于d[i-1]走一个台阶上来或者基于d[i-2]走两个台阶上来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    d := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    d[<span class="number">0</span>], d[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        d[i] = d[i<span class="number">-1</span>] + d[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h3><p><strong>题目</strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 转移方程： d[i] = max&#123;list[i] + d[i-2], d[i-1]&#125;，由于只使用到了前两次的数据，因此只需要有两个变量就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    pre, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        pre, cur = cur, max(cur, pre + v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i&gt;j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h3><p><strong>题目</strong></p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p><strong>题解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用动态规划</span></span><br><span class="line"><span class="comment">// d[i]表示以i结束的子数组的最大和，但是这里只依赖d[i-1]，因此可以使用一个变量sum来表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max, sum := nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            sum = v</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">            max = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h3><p><strong>题目</strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure>


<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<p><strong>题解</strong></p>
<p>动态规划</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划，dp[i]中保存i的最小钞票张数，那么d[i]就是min&#123;d[i-v]+1, 其中v是小于i的钞票面额&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(coins)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; amount &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		dp[v] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := coins[<span class="number">0</span>]+<span class="number">1</span>; i &lt; amount+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> dp[i] == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> coins &#123;</span><br><span class="line">			<span class="keyword">if</span> v &gt; i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> dp[i-v] != <span class="number">-1</span> &amp;&amp; (dp[i] == <span class="number">-1</span> || dp[i-v]+<span class="number">1</span> &lt; dp[i]) &#123;</span><br><span class="line">				dp[i] = dp[i-v] + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="120-三角形最小路径和（经典）"><a href="#120-三角形最小路径和（经典）" class="headerlink" title="120. 三角形最小路径和（经典）"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a>（经典）</h3><p><strong>题目</strong></p>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：</p>
<ul>
<li>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</li>
</ul>
<p><strong>题解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划，dp[j][i]表示第j行第i列的最小路径，dp[j][i]=min&#123;dp[j-1][i], dp[j-1][i-1]&#125;</span></span><br><span class="line"><span class="comment">// 由于dp[j][i]只与dp的第j-1行有关，因此可以将dp改成1维</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumTotal</span><span class="params">(triangle [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(triangle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(triangle))</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> triangle &#123;</span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">1</span> &#123;</span><br><span class="line">			dp[<span class="number">0</span>] = v[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        dp[<span class="built_in">len</span>(v)<span class="number">-1</span>] = dp[<span class="built_in">len</span>(v)<span class="number">-2</span>] + v[<span class="built_in">len</span>(v)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="built_in">len</span>(v)<span class="number">-2</span>; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">            dp[i] = v[i] + min(dp[i], dp[i<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + v[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">	minStep := dp[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> dp[<span class="number">1</span>:] &#123;</span><br><span class="line">		minStep = min(minStep, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minStep</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i&lt;j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h3><p><strong>题目</strong></p>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<ul>
<li><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 </p>
</li>
<li><p>你算法的时间复杂度应该为 O(n2) 。</p>
</li>
</ul>
<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p><strong>题解</strong></p>
<p>常规的动态规划</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划，dp[i]表示以i结尾的最长长度，dp[i]=max&#123;dp[j]+1, 0&lt;=j&lt;i &amp;&amp; nums[j]&lt;nums[i]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        dp[i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j &lt;= i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i+<span class="number">1</span>] &gt; nums[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i+<span class="number">1</span>] &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[j] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过栈和二分查找</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// O(nlogn)</span></span><br><span class="line">    rec := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)) <span class="comment">// 记录和更新当前每个位置可能的最小值</span></span><br><span class="line">    res := <span class="number">0</span> <span class="comment">// 当前最长长度，其实也是rec的长度</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        left, right := <span class="number">0</span>, res</span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">            mid := (left+right)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rec[mid] &lt; nums[i] &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right == res &#123;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            rec[right] = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rec[left] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h3><p><strong>题目</strong></p>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure>



<p><strong>题解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划，dp[i][j]表示从[0, 0]到[i, j]的最小路径和，转移方程dp[i][j]=min&#123;dp[i][j-1], dp[i-1][j]&#125;+grid[i][j]</span></span><br><span class="line"><span class="comment">// 由于dp[i][j]只跟dp[i-1][]相关，因此可以简化成一维，转移方程dp[j]=min&#123;dp[j-1], dp[j]&#125;+grid[i][j]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp[<span class="number">1</span>:] &#123;</span><br><span class="line">        dp[i+<span class="number">1</span>] = grid[<span class="number">0</span>][i+<span class="number">1</span>] + dp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">            dp[j] = min(dp[j<span class="number">-1</span>], dp[j]) + grid[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i&lt;j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h3><p><strong>题目</strong></p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<table>
<thead>
<tr>
<th>-2 (K)</th>
<th>-3</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody></table>
<p>说明:</p>
<p>骑士的健康点数没有上限。</p>
<p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>
<p><strong>题解</strong></p>
<p>这道题目如果通过正向的思维（从骑士的位置走到公主的位置）来暴力求解会产生一定的问题：</p>
<ul>
<li>骑士在<code>[i,j]</code>位置时可以选择从<code>[i-1,j]</code>或者<code>[i,j-1]</code>过来，在选择时应该以什么策略进行判断？<code>d[i][j]</code>里面是不是还需要记录初始最小血量和当前的血量？</li>
<li>这里既需要考虑初始血量最小，又需要考虑有些房间是可以加血的，那么在选择下一步的时候到底应该选初始血量小的还是走过去之后当前血量更大的？</li>
</ul>
<p>以上问题其实没有办法判断，无法使用贪心的方式来决策。那么我们可以换一个思路，从后往前看：假如骑士从<code>[i,j]</code>这个位置出发到达终点那么最少需要多少初始血量：</p>
<ul>
<li>我们可以从后往前看，我们假设<code>d[i][j]</code>表示的是骑士从<code>[i,j]</code>这个位置出发所需要的初始血量，当<code>d[i][j]</code>是负数时表示初始需要血量，且后面缺少的血量为<code>1-d[i][j]</code>，<code>d[i][j]</code>是0则表示初始不需要血</li>
<li>我们知道骑士的下一步只能走右边或者下面，因此<code>d[i][j]</code>只与<code>d[i][j+1]</code>（右）和<code>d[i+1][j]</code>（下）有关，因此我们要选的是<code>d[i][j+1]</code>和<code>d[i+1][j]</code>中血量最大的那个，这样对于<code>d[i][j]</code>是最有利的，因此转移方程就变成了<code>d[i][j]= max{d[i][j+1], d[i+1][j]} + l[i][j]</code>，如果算下来<code>d[i][j]&gt;0</code>，那么就说明骑士从<code>[i,j]</code>这个位置出发到达终点是不需要血量的，也就是<code>d[i][j]=0</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[j] = max&#123;dp[j], dp[j+1]&#125; + dungeon[i][j]</span></span><br><span class="line"><span class="comment">// 其中i表示房间的行数，j表示列数，dp[j]表示骑士剩余的血量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateMinimumHP</span><span class="params">(dungeon [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(dungeon), <span class="built_in">len</span>(dungeon[<span class="number">0</span>])</span><br><span class="line">    dp:=<span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="comment">// 初始化血量</span></span><br><span class="line">    dp[m<span class="number">-1</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++&#123;</span><br><span class="line">        dp[i]=<span class="number">-65535</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        <span class="comment">// 对于最后一列，只跟下面的一行的状态有关</span></span><br><span class="line">        dp[m<span class="number">-1</span>]+=dungeon[i][m<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> dp[m<span class="number">-1</span>]&gt;<span class="number">0</span> &#123;</span><br><span class="line">            dp[m<span class="number">-1</span>]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于其他列，需要同时考虑下面一行和右边一列的状态，两者取血量最大的那个</span></span><br><span class="line">        <span class="keyword">for</span> j:=m<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--&#123;</span><br><span class="line">            <span class="keyword">if</span> dp[j+<span class="number">1</span>]&gt;dp[j] &#123;</span><br><span class="line">                dp[j]=dp[j+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j]+=dungeon[i][j]</span><br><span class="line">            <span class="keyword">if</span> dp[j]&gt;<span class="number">0</span> &#123;</span><br><span class="line">                dp[j]=<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>-dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="10、复杂数据结构"><a href="#10、复杂数据结构" class="headerlink" title="10、复杂数据结构"></a>10、复杂数据结构</h2><h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></h3><p><strong>题目</strong></p>
<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="built_in">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.<span class="keyword">insert</span>("apple");</span><br><span class="line">trie.<span class="keyword">search</span>("apple");   // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">search</span>("app");     // 返回 <span class="keyword">false</span></span><br><span class="line">trie.startsWith("app"); // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">insert</span>("app");   </span><br><span class="line">trie.<span class="keyword">search</span>("app");     // 返回 <span class="keyword">true</span></span><br></pre></td></tr></table></figure>


<p>说明:</p>
<ul>
<li><p>你可以假设所有的输入都是由小写字母 a-z 构成的。 </p>
</li>
<li><p>保证所有输入均为非空字符串。</p>
</li>
</ul>
<p><strong>题解</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    child [<span class="number">26</span>]*Trie</span><br><span class="line">    end   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        index := word[i] - <span class="string">'a'</span></span><br><span class="line">        <span class="comment">// 当前字符不在Trie树中时，增加这个节点</span></span><br><span class="line">        <span class="keyword">if</span> this.child[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            this.child[index] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this指向下一级，进入下一个循环</span></span><br><span class="line">        this = this.child[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后一个字符标记为End</span></span><br><span class="line">    this.end = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        index := word[i] - <span class="string">'a'</span></span><br><span class="line">        <span class="comment">// 当前字符不在Trie树中时，返回false</span></span><br><span class="line">        <span class="keyword">if</span> this.child[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this指向下一级，进入下一个循环</span></span><br><span class="line">        this = this.child[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回末尾单词的标记</span></span><br><span class="line">    <span class="keyword">return</span> this.end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prefix)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        index := prefix[i] - <span class="string">'a'</span></span><br><span class="line">        <span class="comment">// 当前字符不在Trie树中时，返回false</span></span><br><span class="line">        <span class="keyword">if</span> this.child[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// this指向下一级，进入下一个循环</span></span><br><span class="line">        this = this.child[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h3 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">211. 添加与搜索单词 - 数据结构设计</a></h3><p><strong>题目</strong></p>
<p>设计一个支持以下两种操作的数据结构：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">word</span>)</span></span></span><br></pre></td></tr></table></figure>


<p>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。</p>
<p>示例:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"bad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"dad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"mad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"pad"</span>)</span></span> -&gt; false</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"bad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">".ad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"b.."</span>)</span></span> -&gt; true</span><br></pre></td></tr></table></figure>


<p>说明:</p>
<p>你可以假设所有单词都是由小写字母 a-z 组成的。</p>
<p><strong>题解</strong></p>
<p>由于存在’.’，所以遇到时需要通过遍历来查找后面是否有匹配，这里用的是dfs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WordDictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *Trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    child [<span class="number">26</span>]*Trie</span><br><span class="line">    end   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">WordDictionary</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> WordDictionary&#123;</span><br><span class="line">        root: &amp;Trie&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span> <span class="title">AddWord</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    root, n := this.root, <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        index := word[i] - <span class="string">'a'</span></span><br><span class="line">        <span class="keyword">if</span> root.child[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            root.child[index] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.child[index]</span><br><span class="line">    &#125;</span><br><span class="line">    root.end = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(this.root, word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *Trie, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">nil</span> &amp;&amp; root.end</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> word[<span class="number">0</span>] == <span class="string">'.'</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> root.child[i] != <span class="literal">nil</span> &amp;&amp; dfs(root.child[i], word[<span class="number">1</span>:]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    index := word[<span class="number">0</span>] - <span class="string">'a'</span></span><br><span class="line">    <span class="keyword">if</span> root.child[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root.child[index].end</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(root.child[index], word[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AddWord(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h3 id="547-朋友圈（并查集）"><a href="#547-朋友圈（并查集）" class="headerlink" title="547. 朋友圈（并查集）"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a>（并查集）</h3><p><strong>题目</strong></p>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="number">2</span> </span><br><span class="line">说明：已知学生<span class="number">0</span>和学生<span class="number">1</span>互为朋友，他们在一个朋友圈。</span><br><span class="line">第<span class="number">2</span>个学生自己在一个朋友圈。所以返回<span class="number">2</span>。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">说明：已知学生<span class="number">0</span>和学生<span class="number">1</span>互为朋友，学生<span class="number">1</span>和学生<span class="number">2</span>互为朋友，所以学生<span class="number">0</span>和学生<span class="number">2</span>也是朋友，所以他们三个在一个朋友圈，返回<span class="number">1</span>。</span><br></pre></td></tr></table></figure>


<p>注意：</p>
<p>N 在[1,200]的范围内。<br>对于所有学生，有M[i][i] = 1。<br>如果有M[i][j] = 1，则有M[j][i] = 1。</p>
<p><strong>题解</strong></p>
<p>并查集</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findCircleNum</span><span class="params">(M [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(M)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    head, sum := <span class="built_in">make</span>([]<span class="keyword">int</span>, n), n</span><br><span class="line">    <span class="comment">// 初始化head，每个人的head都是自己</span></span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> head &#123;</span><br><span class="line">        head[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> M[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> x, y := find(head, i), find(head, j); x != y &#123;</span><br><span class="line">                    join(head, j, x)</span><br><span class="line">                    sum --</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到i对应的head</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(head []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> head[i] != i &#123;</span><br><span class="line">        i = head[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把i这条线路上的所有节点的head都改成j</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">join</span><span class="params">(head []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果i自己不是head，则将i的head也join进来</span></span><br><span class="line">    <span class="keyword">if</span> head[i] != i &#123;</span><br><span class="line">        join(head, head[i], j)</span><br><span class="line">    &#125;</span><br><span class="line">    head[i] = j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="307-区域和检索-数组可修改（树状数组）"><a href="#307-区域和检索-数组可修改（树状数组）" class="headerlink" title="307. 区域和检索 - 数组可修改（树状数组）"></a><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307. 区域和检索 - 数组可修改</a>（树状数组）</h3><p><strong>题目</strong></p>
<p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">9</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>


<p>说明:</p>
<ul>
<li><p>数组仅可以在 update 函数下进行修改。 </p>
</li>
<li><p>你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。</p>
</li>
</ul>
<p><strong>题解</strong></p>
<p>树状数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组问题</span></span><br><span class="line"><span class="comment">// 注意几个关键操作就行：</span></span><br><span class="line"><span class="comment">// 1. i的低位为i&amp;(-i)</span></span><br><span class="line"><span class="comment">// 2. i的父节点为i + i&amp;(-i)</span></span><br><span class="line"><span class="comment">// 3. 树状数组是从1开始索引的，因此需要做一下转换</span></span><br><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">    tree []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">NumArray</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    array := NumArray&#123;</span><br><span class="line">        items: <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>),</span><br><span class="line">        tree:  <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		array.items[i] = nums[i<span class="number">-1</span>]</span><br><span class="line">		array.tree[i] = nums[i<span class="number">-1</span>] + array.tree[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里的初始化一定要理解</span></span><br><span class="line">	<span class="keyword">for</span> i:=n; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">		array.tree[i] -= array.tree[i-(i&amp;(-i))]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">Update</span><span class="params">(i <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	i++</span><br><span class="line">	diff := val - this.items[i]</span><br><span class="line">	this.items[i] = val</span><br><span class="line">	<span class="keyword">for</span> i&lt;<span class="built_in">len</span>(this.tree) &#123;</span><br><span class="line">		this.tree[i] += diff</span><br><span class="line">		i += i&amp;(-i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">SumRange</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum, i, j := <span class="number">0</span>, i+<span class="number">1</span>, j+<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i--; i &gt; <span class="number">0</span>; i -= i&amp;(-i) &#123;</span><br><span class="line">		sum -= this.tree[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ; j &gt; <span class="number">0</span>; j -= j&amp;(-j) &#123;</span><br><span class="line">		sum += this.tree[j]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(nums);</span></span><br><span class="line"><span class="comment"> * obj.Update(i,val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.SumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>yost
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yost.top/2019/12/04/linmu-leetcode/" title="leetcode课程记录（讲师：林沐）">http://yost.top/2019/12/04/linmu-leetcode/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/26/leetcode-review/" rel="prev" title="leetcode题解持续更新">
      <i class="fa fa-chevron-left"></i> leetcode题解持续更新
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/13/create-cluster-by-vagrant/" rel="next" title="在windows上通过vagrant和virtualbox一键搭建k8s集群">
      在windows上通过vagrant和virtualbox一键搭建k8s集群 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、链表"><span class="nav-text">1、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#206-反转链表"><span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-反转链表-II"><span class="nav-text">92. 反转链表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-相交链表"><span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-环形链表"><span class="nav-text">141. 环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-环形链表-II"><span class="nav-text">142. 环形链表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-分隔链表"><span class="nav-text">86. 分隔链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-合并K个排序链表"><span class="nav-text">23. 合并K个排序链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、栈、队列和堆"><span class="nav-text">2、栈、队列和堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#225-用队列实现栈"><span class="nav-text">225. 用队列实现栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#232-用栈实现队列"><span class="nav-text">232. 用栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#155-最小栈"><span class="nav-text">155. 最小栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#224-基本计算器"><span class="nav-text">224. 基本计算器*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215-数组中的第K个最大元素"><span class="nav-text">215. 数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#295-数据流的中位数"><span class="nav-text">295. 数据流的中位数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、贪心算法"><span class="nav-text">3、贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#455-分发饼干"><span class="nav-text">455. 分发饼干</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#376-摆动序列"><span class="nav-text">376. 摆动序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#402-移掉K位数字"><span class="nav-text">402. 移掉K位数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-text">55. 跳跃游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-跳跃游戏-II"><span class="nav-text">45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#452-用最少数量的箭引爆气球"><span class="nav-text">452. 用最少数量的箭引爆气球</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、递归、回溯与分治"><span class="nav-text">4、递归、回溯与分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#78-子集"><span class="nav-text">78. 子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-子集-II"><span class="nav-text">90. 子集 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-组合总和"><span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-组合总和-II"><span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-括号生成"><span class="nav-text">22. 括号生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N皇后"><span class="nav-text">51. N皇后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#315-计算右侧小于当前元素的个数"><span class="nav-text">315. 计算右侧小于当前元素的个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、二叉树与图"><span class="nav-text">5、二叉树与图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#112-路径总和"><span class="nav-text">112. 路径总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-路径总和-II"><span class="nav-text">113. 路径总和 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-二叉树的最近公共祖先"><span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-二叉树展开为链表"><span class="nav-text">114. 二叉树展开为链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#199-二叉树的右视图"><span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-课程表"><span class="nav-text">207. 课程表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、二分查找与二叉排序树"><span class="nav-text">6、二分查找与二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#35-搜索插入位置"><span class="nav-text">35. 搜索插入位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-搜索旋转排序数组"><span class="nav-text">33. 搜索旋转排序数组*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#315-计算右侧小于当前元素的个数-1"><span class="nav-text">315. 计算右侧小于当前元素的个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、哈希表与字符串"><span class="nav-text">7、哈希表与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#409-最长回文串"><span class="nav-text">409. 最长回文串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#290-单词规律"><span class="nav-text">290. 单词规律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-字母异位词分组"><span class="nav-text">49. 字母异位词分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-text">3. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#187-重复的DNA序列"><span class="nav-text">187. 重复的DNA序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-最小覆盖子串"><span class="nav-text">76. 最小覆盖子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、搜索"><span class="nav-text">8、搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#200-岛屿数量"><span class="nav-text">200. 岛屿数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-单词接龙"><span class="nav-text">127. 单词接龙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#126-单词接龙-II"><span class="nav-text">126. 单词接龙 II*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#473-火柴拼正方形"><span class="nav-text">473. 火柴拼正方形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#407-接雨水-II"><span class="nav-text">407. 接雨水 II*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、动态规划"><span class="nav-text">9、动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#70-爬楼梯"><span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-打家劫舍"><span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-最大子序和"><span class="nav-text">53. 最大子序和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322-零钱兑换"><span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-三角形最小路径和（经典）"><span class="nav-text">120. 三角形最小路径和（经典）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-最长上升子序列"><span class="nav-text">300. 最长上升子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-最小路径和"><span class="nav-text">64. 最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#174-地下城游戏"><span class="nav-text">174. 地下城游戏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、复杂数据结构"><span class="nav-text">10、复杂数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#208-实现-Trie-前缀树"><span class="nav-text">208. 实现 Trie (前缀树)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#211-添加与搜索单词-数据结构设计"><span class="nav-text">211. 添加与搜索单词 - 数据结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#547-朋友圈（并查集）"><span class="nav-text">547. 朋友圈（并查集）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#307-区域和检索-数组可修改（树状数组）"><span class="nav-text">307. 区域和检索 - 数组可修改（树状数组）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yost</p>
  <div class="site-description" itemprop="description">种一棵树最好的时间是十年前，其次是现在~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yost</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">179k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:42</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='50' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
