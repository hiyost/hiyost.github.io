<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yost.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我们知道，在kubernetes中，有5个主要的组件，分别是管理节点上的kube-apiserver、kube-controller-manager和kube-scheduler，node节点上的kubelet和kube-proxy。这其中kube-apiserver是对外和对内提供资源的声明式API的组件，其它4个组件都需要和它交互，在这个交互过程中，有一个非常关键的机制就是list-watch">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解k8s中的list-watch机制">
<meta property="og:url" content="http://yost.top/2019/08/01/inside-list-watch-in-k8s/index.html">
<meta property="og:site_name" content="yost">
<meta property="og:description" content="我们知道，在kubernetes中，有5个主要的组件，分别是管理节点上的kube-apiserver、kube-controller-manager和kube-scheduler，node节点上的kubelet和kube-proxy。这其中kube-apiserver是对外和对内提供资源的声明式API的组件，其它4个组件都需要和它交互，在这个交互过程中，有一个非常关键的机制就是list-watch">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yost.top/2019/08/01/inside-list-watch-in-k8s/client-go-controller-interaction.jpg">
<meta property="og:image" content="http://o6sfmikvw.bkt.clouddn.com/listwatch.png">
<meta property="og:image" content="http://yost.top/2019/08/01/inside-list-watch-in-k8s/client-go-controller-interaction.jpg">
<meta property="article:published_time" content="2019-08-01T13:06:45.000Z">
<meta property="article:modified_time" content="2020-06-01T15:23:36.267Z">
<meta property="article:author" content="yost">
<meta property="article:tag" content="list-watch, k8s, client-go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yost.top/2019/08/01/inside-list-watch-in-k8s/client-go-controller-interaction.jpg">

<link rel="canonical" href="http://yost.top/2019/08/01/inside-list-watch-in-k8s/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入理解k8s中的list-watch机制 | yost</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yost</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yost.top/2019/08/01/inside-list-watch-in-k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yost">
      <meta itemprop="description" content="种一棵树最好的时间是十年前，其次是现在~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yost">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解k8s中的list-watch机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-01 21:06:45" itemprop="dateCreated datePublished" datetime="2019-08-01T21:06:45+08:00">2019-08-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我们知道，在<code>kubernetes</code>中，有5个主要的组件，分别是管理节点上的<code>kube-apiserver</code>、<code>kube-controller-manager</code>和<code>kube-scheduler</code>，<code>node</code>节点上的<code>kubelet</code>和<code>kube-proxy</code>。这其中<code>kube-apiserver</code>是对外和对内提供资源的声明式API的组件，其它4个组件都需要和它交互，在这个交互过程中，有一个非常关键的机制就是<code>list-watch</code>。我们知道<code>kube-apiserver</code>提供了一个<code>kubernetes</code>中各种资源的增删改查的接口，不对需要对内给这4个组件用，还需要给外外部的用户以及集群内可能安装的插件使用，因此它接收到的请求量是十分巨大的，为了减少这种请求量，降低<code>kube-apiserver</code>的压力，便设计出了<code>list-watch</code>机制。<code>client</code>端在跟<code>server</code>端长期进行交互时，并不是每次需要查询时都去调用server的接口，而是使用<code>list</code>+<code>watch</code>的方式来维护一个缓存将<code>server</code>端的数据缓存起来，当需要获取数据的时候直接从缓存中获取，一方面可以降低<code>server</code>端的压力，另一方面也可以减少自己获取数据的时间。当然，增删改还是需要调用server端的接口。</p>
<p>本文的目的是将<code>list-watch</code>的机制搞清楚，各位看官且往下看。</p>
<blockquote>
<p>说明：本文使用的k8s代码为<a href="https://github.com/kubernetes/kubernetes/tree/release-1.13" target="_blank" rel="noopener">1.13版本</a>，其他版本代码可能会有少许差异。</p>
</blockquote>
<a id="more"></a>

<h1 id="0、啥是list-watch"><a href="#0、啥是list-watch" class="headerlink" title="0、啥是list-watch"></a>0、啥是<code>list-watch</code></h1><p>在k8s中，<code>list-watch</code>本质上还是client端监听k8s资源变化并作出相应处理的生产者消费者框架。因此在分析这部分的代码之前就会有问题在脑海中：生产者是谁？消费者是谁？传递了啥？怎么传递的？</p>
<p>除此之外，往往生产者只有一个，消费者有多个，这种情况下怎么保证每个消费者都能收到消息？</p>
<p>好，带着这些问题，我们慢慢往下看。</p>
<h2 id="0-1、list与watch"><a href="#0-1、list与watch" class="headerlink" title="0.1、list与watch"></a>0.1、<code>list</code>与<code>watch</code></h2><p>从字面上看，<code>list</code>就是获取静态的所有数据，而<code>watch</code>则是只关心发生了变化的那部分。对于<code>client</code>端而言，list是获取当前所有值列表的方法，主要用来查询，而<code>watch</code>则是用来监听每个资源的增删改事件。<code>list</code>是一般的<code>rest api</code>中都会实现的功能，我们这里重点讲一下<code>watch</code>。</p>
<h2 id="0-2、使用场景"><a href="#0-2、使用场景" class="headerlink" title="0.2、使用场景"></a>0.2、使用场景</h2><p>在阅读<code>list-watch</code>的代码之前，我们来先思考一下它的使用场景。根据文章开头说到的一些功能，我们可以梳理部分需求：</p>
<ul>
<li>可以<code>watch</code>特定的资源，并根据资源的变动类型（增删改）进行不同的处理</li>
<li><code>watch</code>到变化时将这个变化加如到队列中，由处理逻辑从队列中取，将事件的生产和消费分离开来</li>
<li>想要查询某个资源时只需要从缓存中获取，不需要向<code>kube-apiserver</code>发请求</li>
<li>对于某些特定的资源，除了能<code>watch</code>变化以外，还能定期产生变化的事件，用来做周期性检查</li>
<li>多个不同的<code>controller</code>可能需要<code>watch</code>同一个资源，因此希望能在同一个<code>watch</code>的架构中能共享缓存并且能分别接收同一个资源的相同事件</li>
</ul>
<h2 id="0-3、代码目录"><a href="#0-3、代码目录" class="headerlink" title="0.3、代码目录"></a>0.3、代码目录</h2><p>基本数据结构和算法的代码主要位于<code>staging/src/k8s.io/client-go/tools/cache</code>这个目录中，其中去掉UT测试的文件之后约3.6k代码，十分精巧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BUILD</span><br><span class="line">├── controller.go</span><br><span class="line">├── delta_fifo.go</span><br><span class="line">├── doc.go</span><br><span class="line">├── expiration_cache_fakes.go</span><br><span class="line">├── expiration_cache.go</span><br><span class="line">├── fake_custom_store.go</span><br><span class="line">├── fifo.go</span><br><span class="line">├── heap.go</span><br><span class="line">├── index.go</span><br><span class="line">├── listers.go</span><br><span class="line">├── listwatch.go</span><br><span class="line">├── mutation_cache.go</span><br><span class="line">├── mutation_detector.go</span><br><span class="line">├── OWNERS</span><br><span class="line">├── reflector.go</span><br><span class="line">├── reflector_metrics.go</span><br><span class="line">├── shared_informer.go</span><br><span class="line">├── store.go</span><br><span class="line">├── thread_safe_store.go</span><br><span class="line">└── undelta_store.go</span><br></pre></td></tr></table></figure>



<h2 id="0-4、list-watch的架构"><a href="#0-4、list-watch的架构" class="headerlink" title="0.4、list-watch的架构"></a>0.4、<code>list-watch</code>的架构</h2><p><img src="/2019/08/01/inside-list-watch-in-k8s/client-go-controller-interaction.jpg" alt="img"></p>
<h1 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h1><h2 id="1-1、基础数据结构threadSafeMap和cache"><a href="#1-1、基础数据结构threadSafeMap和cache" class="headerlink" title="1.1、基础数据结构threadSafeMap和cache"></a>1.1、基础数据结构<code>threadSafeMap</code>和<code>cache</code></h2><h3 id="1-1-1、threadSafeMap"><a href="#1-1-1、threadSafeMap" class="headerlink" title="1.1.1、threadSafeMap"></a>1.1.1、<code>threadSafeMap</code></h3><p>前面说到<code>list-watch</code>本质上是一个生产者消费者框架，最关键的是数据的传递，那么传递的数据的数据结构很重要，在<code>list-watch</code>中，最为底层的数据结构其实是一个线程安全的map：</p>
<p>代码位于<code>staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">	indexers Indexers</span><br><span class="line">	<span class="comment">// indices maps a name to an Index</span></span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的<code>threadSafeMap</code>的结构非常简单：</p>
<ul>
<li><code>lock sync.RWMutex</code>是一个读写锁，用来保证线程安全</li>
<li><code>items map[string]interface{}</code>，这是一个<code>key</code>为<code>string</code>、<code>value</code>是任意类型的<code>map</code>，也是实际数据存放的最关键的数据结构，所有的操作最终都是跟这个<code>map</code>打交道，<code>key</code>是存储对象的唯一索引，<code>value</code>是存储的对象</li>
<li><code>indexers Indexers</code>是用于给<code>map</code>中的<code>value</code>数据做检索（也就是计算<code>value</code>的<code>key</code>）的函数，<code>Indexers</code>实际的数据结构是<code>map[string]IndexFunc</code>，注意可以有多个索引函数，且每个函数的返回值可以是多个。可以把<code>IndexFunc</code>理解为聚类函数。常用的<code>IndexFunc</code>有<code>MetaNamespaceIndexFunc</code>（返回对象的<code>namespace</code>）和<code>indexByPodNodeName</code>（返回Pod对象所在节点的名字）。</li>
<li><code>indices Indices</code>则是保存索引后的数据的<code>map[][]sets.String</code>，第一个key是<code>Indexers</code>中索引函数的名字，第二个key是这个索引函数返回值的索引，<code>sets.String</code>则是对应该索引值的所有<code>items</code>对象的key，这是一个已经按照索引分类好了的三维map。</li>
</ul>
<blockquote>
<p>注：关于<code>threadSafeMap</code>中的<code>indexers</code>和<code>indices</code>这两个元素的作用，后面会在<code>Indexer</code>中继续说明，这其实是<code>list-watch</code>之所以高效的一个重要原因。</p>
</blockquote>
<h4 id="1-1-1-1、实现的接口ThreadSafeStore"><a href="#1-1-1-1、实现的接口ThreadSafeStore" class="headerlink" title="1.1.1.1、实现的接口ThreadSafeStore"></a>1.1.1.1、实现的接口<code>ThreadSafeStore</code></h4><p>不难看到<code>threadSafeMap</code>是一个私有的结构体，实际在使用时是通过它所实现的接口<code>ThreadSafeStore</code>来对里面的<code>map</code>进行数据操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadSafeStore 本质上是threadSafeMap实现的所有接口，也是对其中数据的封装，防止外部直接使用map</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 这部分是通过key对map进行增删改查等数据相关的基本操作，这些操作中会对indices表进行“日常”维护</span></span><br><span class="line">	Add(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Update(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Delete(key <span class="keyword">string</span>)</span><br><span class="line">	Get(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>)</span><br><span class="line">	List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ListKeys() []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Replace 的第二个入参是resourceVersion，但是函数中似乎并没有用到</span></span><br><span class="line">	Replace(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>)</span><br><span class="line">    <span class="comment">// 这部分是一些高级的查询方法，主要是些同类索引的查询，后面的Indexer接口的实现依赖这部分功能</span></span><br><span class="line">	Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">	ListIndexFuncValues(name <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">	ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给threadSafeMap增加Indexers函数，一定要在初始化（map中还没有数据）的时候做，否则直接报错</span></span><br><span class="line">	AddIndexers(newIndexers Indexers) error</span><br><span class="line">    <span class="comment">// 暂时还未实现任何功能的函数，实际直接返回了nil</span></span><br><span class="line">	Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里定义了包括增删改查等所有对数据进行操作的函数，而前面所说的<code>threadSafeMap</code>均实现了这里面所有的接口，因此在实际使用的时候都是通过<code>ThreadSafeStore</code>接口来进行操作，这样做的目的也很容易理解：将数据隐藏，只暴露操作这些数据的接口。实际就是面向对象的理念。</p>
<h4 id="1-1-1-2、如何创建"><a href="#1-1-1-2、如何创建" class="headerlink" title="1.1.1.2、如何创建"></a>1.1.1.2、如何创建</h4><p>在创建新的数据时，由于<code>threadSafeMap</code>是这个<code>package</code>里面“不可导出”的，虽然创建的是<code>threadSafeMap</code>实例，但函数真正的返回值是<code>ThreadSafeStore</code>这个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThreadSafeStore</span><span class="params">(indexers Indexers, indices Indices)</span> <span class="title">ThreadSafeStore</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;threadSafeMap&#123;</span><br><span class="line">		items:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		indexers: indexers,</span><br><span class="line">		indices:  indices,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewThreadSafeStore</code>的被调方有2个，一个是创建<code>Store</code>的时候，另一个是创建<code>Indexer</code>的时候，后面会讲到。</p>
<p>这里有2个可能需要注意的问题：</p>
<ul>
<li><code>threadSafeMap</code>的定义里面<code>items map[string]interface{}</code>，但是在创建时<code>items:    map[string]interface{}{}</code>，后面的<code>{}</code>其实是对这个map的初始化，这时候<code>items</code>已经不为<code>nil</code>了</li>
<li><code>NewThreadSafeStore</code>函数中似乎并没有对<code>lock  sync.RWMutex</code>进行显式初始化，go语言中这种初始化方式中某个成员变量没有指定，那么它的值就是该成员变量类型的零值</li>
</ul>
<h3 id="1-1-2、cache"><a href="#1-1-2、cache" class="headerlink" title="1.1.2、cache"></a>1.1.2、<code>cache</code></h3><p>了解了最底层的数据结构<code>threadSafeMap</code>和其实现的接口<code>ThreadSafeStore</code>之后，接下来看其更上一层的封装<code>cache</code>和其实现的接口<code>Store</code>和<code>Indexer</code>。注意<code>cache</code>既是这个结构体的名字，也是当前这个package的名字，可见其重要性。</p>
<p>从其成员变量中可以看到<code>cache</code>相对于<code>threadSafeMap</code>而言最大的区别是多了一个<code>KeyFunc</code>（其定义是通过<code>obj</code>返回其对应的<code>key</code>字符串，这个<code>key</code>主要是给map做<strong>唯一</strong>索引用的）。</p>
<p>代码位于<code>staging/src/k8s.io/client-go/tools/cache/store.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache定义了对出对象的key索引函数，并实现了ThreadSafeStore的所有方法</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">	cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc用来确定对象的唯一性索引值，也就是计算map中的key值，最常用的keyFunc是MetaNamespaceKeyFunc，即取对象的“&#123;namespace&#125;/&#123;name&#125;”作为key</span></span><br><span class="line">	keyFunc KeyFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KeyFunc <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于确认cache实现了Store的所有接口，否则编译会出错（疑问：为啥Indexer不需要确认？）</span></span><br><span class="line"><span class="keyword">var</span> _ Store = &amp;cache&#123;&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1-1-2-1、实现的接口Store"><a href="#1-1-2-1、实现的接口Store" class="headerlink" title="1.1.2.1、实现的接口Store"></a>1.1.2.1、实现的接口<code>Store</code></h4><p>可以看到，实现了<code>Store</code>接口的<code>cache</code>结构体相比于实现了<code>ThreadSafeStore</code>接口的<code>threadSafeMap</code>结构体也只是多了一个<code>keyFunc</code>而已，并且<code>Store</code>中没有用到<code>indexers</code>函数，仅仅只是一个通过key值来做索引的map。常用的<code>keyFunc</code>是<code>MetaNamespaceKeyFunc</code>，即取对象的<code>{namespace}/{name}</code>作为key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store是一个通用的对象存储接口，并没有index的能力，因此常常用来做list-watch的队列载体</span></span><br><span class="line"><span class="comment">// 只不过cache和后面讲到的队列都实现了这个接口而已</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 这部分是对map进行增删改查等数据相关的基本操作，不需要做index</span></span><br><span class="line">	Add(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	Update(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	Delete(obj <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ListKeys() []<span class="keyword">string</span></span><br><span class="line">	Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">	GetByKey(key <span class="keyword">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="keyword">bool</span>, err error)</span><br><span class="line">	<span class="comment">// Replace的第二个入参是resourceVersion，cache并没有用到，后面的队列中会用来</span></span><br><span class="line">	Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">string</span>) error</span><br><span class="line">    <span class="comment">// Resync主要是后面讲到的队列用到的，cache中并没有使用到</span></span><br><span class="line">	Resync() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以先定义一套<code>Store</code>接口，是因为有很多地方其实并不需要使用索引功能，而只是需要一个线程安全的map而已（例如队列<code>Queue</code>）。</p>
<h4 id="1-1-2-2、实现的接口Indexer"><a href="#1-1-2-2、实现的接口Indexer" class="headerlink" title="1.1.2.2、实现的接口Indexer"></a>1.1.2.2、实现的接口<code>Indexer</code></h4><p><strong><code>cache</code>除了实现了<code>Store</code>的接口以外，还实现了<code>Indexers</code>的接口</strong>，前者是<code>informer</code>使用的方式，后者是<code>reflector</code>的使用方式，注意这一点十分重要。<code>Indexer</code>本质上就是一个可以定义索引器的<code>Store</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indexer是一个带有索引功能的对象存储接口，通常用来作为list-watch的缓存器</span></span><br><span class="line"><span class="keyword">type</span> Indexer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Store</span><br><span class="line">	<span class="comment">// 获取通过indexName这个函数算出来的索引值和obj这个元素相同的所有元素（也就是找obj的同类）</span></span><br><span class="line">	Index(indexName <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	<span class="comment">// 获取通过indexName这个函数能算出来索引值包含indexKey值的所有元素在map中的key</span></span><br><span class="line">	IndexKeys(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">string</span>, error)</span><br><span class="line">	<span class="comment">// 获取当前元素通过indexName这个函数能算出来的所有索引值（并非map的key）</span></span><br><span class="line">	ListIndexFuncValues(indexName <span class="keyword">string</span>) []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 获取通过indexName这个函数算出来包含有indexKey值的所有元素（与IndexKeys()函数类似）</span></span><br><span class="line">	ByIndex(indexName, indexKey <span class="keyword">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	<span class="comment">// 获取所有的indexers函数</span></span><br><span class="line">	GetIndexers() Indexers</span><br><span class="line">	<span class="comment">// 增加Indexers函数，必须在初始化时（map中没有元素）添加，否则直接报错</span></span><br><span class="line">	AddIndexers(newIndexers Indexers) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Indexer</code>可以说是最具有效率的一套存储器接口，原因在于它实现了根据索引来实时分类的功能，什么意思呢？当你定义了这个<code>Indexer</code>的<code>IndexFunc</code>，那么一旦有元素加入到这个<code>Store</code>中来，就会自动给这个元素分组（根据<code>IndexFunc</code>计算的key来进行分组）。这有什么好处呢？假如我需要根据<code>namespace</code>来进行索引（在k8s中这是最常见的索引方式），那么<code>IndexFunc</code>就是根据obj来返回其对应的<code>namespace</code>的值。设想一下如果没有自动索引的功能，我想要查询某个<code>namespace</code>下的所有对象，就需要遍历所有的对象并选出在这个<code>namespace</code>下的对应，需要做一次全量的遍历，而实现了实时索引功能的<code>indexer</code>就不通，由于我已经实现定义了<code>IndexFunc</code>，在每个对象增加进来的时候，我已经根据<code>namespace</code>来分类了（通过<code>threadSafeMap</code>中的<code>indices</code>来维护，<code>indices</code>实际是个<code>map[string][string]sets.String</code>），那么需要查询这个<code>namespace</code>下的所有对象时就只需要直接返回这个<code>set</code>就可以了，不需要遍历所有的对象。当前这个需要在每个对象发生变化的时候事先索引，存在一定的开销，但是对于查询操作带来的便捷是十分巨大的。</p>
<p>以上描述都是通过基本的接口和数据结构来实现的，对应的代码都在<code>staging/src/k8s.io/client-go/tools/cache/index.go</code>中。</p>
<p>首先是检索函数<code>IndexFunc</code>，它定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IndexFunc knows how to provide an indexed value for an object.</span></span><br><span class="line"><span class="keyword">type</span> IndexFunc <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>需要注意以下几点：</p>
<ul>
<li><code>IndexFunc</code>的返回值是一个字符串的<code>slice</code>，而不是一个单独的字符串，这意味着<code>IndexFunc</code>可以是复合类型的索引，这也是为什么<code>Index</code>是一个<code>map</code>。疑问：是否过度设计？</li>
<li><code>Indexer</code>的<code>IndexFunc</code>和<code>cache</code>的<code>keyFunc</code>不同，<code>keyFunc</code>计算的是对象的<strong>唯一确定性</strong>key（所以返回的是一个字符串而不是字符串<code>slice</code>），不同对象经过<code>keyFunc</code>计算出来的key在这个<code>store</code>中是全局唯一的；而<code>IndexFunc</code>是一类对象的key，可能有多个对象都能通过这个<code>IndexFunc</code>计算出相同的key（譬如不同<code>pod</code>的<code>namespace</code>是一样的），这也是设计<code>IndexFunc</code>的初衷</li>
</ul>
<p>为了实现这些逻辑，<code>indexer</code>中还设计了几个关键的数据结构（这几个实际上是<code>threadSafeMap</code>中的元素）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index的key是IndexFunc计算出来的索引值，value是计算出相同索引值的元素的key</span></span><br><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br><span class="line"><span class="comment">// Indexers的key是IndexFunc的名称，value是这个IndexFunc</span></span><br><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="keyword">string</span>]IndexFunc</span><br><span class="line"><span class="comment">// Indices的key是IndexFunc的名称，value是Index</span></span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="keyword">string</span>]Index</span><br></pre></td></tr></table></figure>

<p>其中最需要注意的是<code>type Index map[string]sets.String</code>，这里面的<code>sets.String</code>存放的其实就是<code>Store</code>中<code>map</code>的key（也就是<code>keyFunc</code>返回的对象的<strong>唯一确定性</strong>key）。</p>
<h4 id="1-1-2-3、如何创建"><a href="#1-1-2-3、如何创建" class="headerlink" title="1.1.2.3、如何创建"></a>1.1.2.3、如何创建</h4><p>由于<code>cache</code>在这个package中是“不可导出”的，并不被直接引用，而是通过其实现的两个接口<code>Store</code>和<code>Indexer</code>来使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStore返回的只是一个多了keyFunc的threadSafeStore，但是Indexers是空的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(keyFunc KeyFunc)</span> <span class="title">Store</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">		cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),</span><br><span class="line">		keyFunc:      keyFunc,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到Indexer只是比Store多了Indexers函数而已</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="title">Indexer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">		cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">		keyFunc:      keyFunc,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里需要想办法举一个例子。</p>
<h3 id="1-1-3、总结"><a href="#1-1-3、总结" class="headerlink" title="1.1.3、总结"></a>1.1.3、总结</h3><p>本章节介绍了<code>list-watch</code>机制中最基础的数据结构<code>threadSafeMap</code>和<code>cache</code>，其本质是对一个<code>map[string]interface{}</code>进行增删改查，<code>cache</code>比<code>threadSafeMap</code>多了一个可以定义计算唯一索引方法（map的key值）的函数。为了便于对这个map中的对象进行分类，<code>threadSafeMap</code>中使用了<code>indexers</code>和<code>indices</code>这两个元素，用来维护根据不同维度来对所有对象进行分类的map。<code>cache</code>基于<code>threadSafeMap</code>中的函数实现了<code>Store</code>和<code>Indexer</code>两个interface，区别在于前者是不带分类功能（<code>indexers</code>为空），后者带分类功能。从interface上来讲，关系则稍显复杂，可以把<code>Store</code>当做最基本的操作interface，可拓展的方向很多，<code>Indexer</code>则是其中一种拓展，主要是增加了分类的功能，是<code>Informer</code>的基础。后面会讲到的<code>Queue</code>也是<code>Store</code>的一种拓展，增加了队列相关的出队列（<code>Pop</code>）功能。</p>
<p>这其中几点关键信息需要记住：</p>
<ul>
<li>本章最重要的数据结构是<code>cache</code>这个结构体</li>
<li><code>cache</code>本质上是一个具有检索和自动分类功能map</li>
<li><code>cache</code>实现了<code>Store</code>和<code>Indexer</code>两个接口，后者是前者的拓展，比前者多的就是自动分类功能</li>
<li><code>Store</code>是<code>Reflector</code>的基础数据结构</li>
<li><code>Indexer</code>是<code>Informer</code>的基础数据结构</li>
</ul>
<blockquote>
<p>截止到目前，我们看到的主要就是跟<code>cache</code>相关的数据结构和接口，那么这些跟生产者消费者有什么关系呢？更确切地说，他们跟<code>list-watch</code>是什么关系呢？其实这个<code>cache</code>是<code>list-watch</code>的全量资源缓存，用来将提高查询的效率，降低client和server端的cpu消耗。当然这只是”然”，还需要搞懂”所以然”，我们带着这些疑问继续往下看。</p>
</blockquote>
<h2 id="1-2、基础数据结构FIFO和DeltaFIFO"><a href="#1-2、基础数据结构FIFO和DeltaFIFO" class="headerlink" title="1.2、基础数据结构FIFO和DeltaFIFO"></a>1.2、基础数据结构<code>FIFO</code>和<code>DeltaFIFO</code></h2><p>在生产者消费者模型中，最重要的一个数据结构实际上是队列：</p>
<ul>
<li>生产者将消息或者数据放入到队列中</li>
<li>消费者从队列中取出消息或者数据并对其进行处理</li>
</ul>
<h3 id="1-2-1、FIFO"><a href="#1-2-1、FIFO" class="headerlink" title="1.2.1、FIFO"></a>1.2.1、<code>FIFO</code></h3><p>由于go语言的官方库中并没有实现队列这个数据结构，k8s中自己实现了一套。<code>FIFO</code>是一个先入先出的队列，其中存放关键数据的元素是<code>items map[string]interface{}</code>和<code>queue []string</code>，<code>items</code>中存放的是所有的元素，<code>queue</code>中是通过map中的key值来存放的实际队列（通过slice实现，新增的元素append到最后，pop时取第一个），也就是说<code>FIFO</code>是通过map和slice这两个基础类型来配合实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FIFO 的生产者是Reflector，消费者调用Pop()函数来获取队首的元素</span></span><br><span class="line"><span class="comment">// 当多个生产者向FIFO中增加元素时，FIFO会进行合并处理，只保留最新的元素</span></span><br><span class="line"><span class="comment">// 当消费者使用Pop()函数时获取的也是这个元素的最新版本</span></span><br><span class="line"><span class="keyword">type</span> FIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">    <span class="comment">// cond是一个条件变量，消费者执行Pop()时使用它来wait，生产者将元素加入队列之后通过它来通知消费者</span></span><br><span class="line">	cond sync.Cond</span><br><span class="line">	<span class="comment">// item存放队列中的实际元素</span></span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// queue中仅存放队列中元素的key值（注意queue和items中的数据必须是同步的）</span></span><br><span class="line">	queue []<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 表示队列已经开始运作了（Delete/Add/Update/Replace被调用时都会将其设置为true）</span></span><br><span class="line">	populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 第一次执行Replace()（也就是第一次批量添加元素）时队列中元素的个数，执行Pop()时会递减</span></span><br><span class="line">	initialPopulationCount <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// keyFunc用于计算元素的唯一索引key值</span></span><br><span class="line">	keyFunc KeyFunc</span><br><span class="line">    <span class="comment">// 用来设置这个队列的状态为关闭，并通知所有的消费者可以退出Pop()中的等待</span></span><br><span class="line">	closed     <span class="keyword">bool</span></span><br><span class="line">	closedLock sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	_ = Queue(&amp;FIFO&#123;&#125;) <span class="comment">// FIFO is a Queue</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h4><p>创建一个新的<code>FIFO</code>只需要传入进行唯一索引值计算的<code>KeyFunc</code>就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewFIFO returns a Store which can be used to queue up items to</span></span><br><span class="line"><span class="comment">// process.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFIFO</span><span class="params">(keyFunc KeyFunc)</span> *<span class="title">FIFO</span></span> &#123;</span><br><span class="line">	f := &amp;FIFO&#123;</span><br><span class="line">		items:   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		queue:   []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">		keyFunc: keyFunc,</span><br><span class="line">	&#125;</span><br><span class="line">	f.cond.L = &amp;f.lock</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在k8s的大部分场景并没有使用到<code>FIFO</code>，仅scheduler中使用到了，而在list-watch中主要使用到了后面讲到的<code>DeltaFIFO</code>。</p>
<h3 id="1-2-2、DeltaFIFO"><a href="#1-2-2、DeltaFIFO" class="headerlink" title="1.2.2、DeltaFIFO"></a>1.2.2、<code>DeltaFIFO</code></h3><p>在<code>FIFO</code>中，队列中的元素（实际是map中的value，而不是slice中的key）是一个无状态的对象<code>interface{}</code>，这对于watch事件而言是不够的，watch中需要知道这个对象是新增、删除还是更新，因此k8s又封装了一个叫做<code>DeltaFIFO</code>的队列，主要区别在于结构体中的元素<code>items map[string]interface{}</code>改成了<code>items map[string]Deltas</code>，你可以把他看成是消息或者事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaFIFO的生产者是Reflector，消费者调用Pop()函数来获取队首的元素</span></span><br><span class="line"><span class="comment">// 如果有多个线程中调用，那么他们会获取到版本号稍微不同的元素</span></span><br><span class="line"><span class="comment">// 相较于FIFO，DeltaFIFO队列中可以处理删除的元素（Delete()函数也是往队列中添加元素）</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">    <span class="comment">// cond是一个条件变量，消费者执行Pop()时使用它来wait，生产者将元素加入队列之后通过它来通知消费者</span></span><br><span class="line">	cond sync.Cond</span><br><span class="line">	<span class="comment">// DeltaFIFO最大的区别在于value是一个Deltas，包含了事件（Added/Updated/Deleted/Sync）信息</span></span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    <span class="comment">// queue中仅存放队列中元素的key值（注意queue和items中的数据必须是同步的，Resync()函数的工作）</span></span><br><span class="line">	queue []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 表示队列已经开始运作了（Delete/Add/Update/Replace被调用时都会将其设置为true）</span></span><br><span class="line">	populated <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 第一次执行Replace()（也就是第一次批量添加元素）时队列中元素的个数，执行Pop()时会递减</span></span><br><span class="line">	initialPopulationCount <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// keyFunc用于计算元素的唯一索引key值（留一个小悬念：这个跟cache中的keyFunc是否可以不同？）</span></span><br><span class="line">	keyFunc KeyFunc</span><br><span class="line">	<span class="comment">// 这也是跟FIFO不同的一个地方，实际上就是已知可以操作的所有对象的集合，在Replace/Resync/Delete时需要用来判断该元素是否需要入队"Deleted"的事件，这其实是informer中维护的一个Indexer，包含了全量的缓存，DeltaFIFO中只能对其进行GetByKey和ListKeys，无法进行增删改查</span></span><br><span class="line">	knownObjects KeyListerGetter</span><br><span class="line">	closed     <span class="keyword">bool</span></span><br><span class="line">	closedLock sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	_ = Queue(&amp;DeltaFIFO&#123;&#125;) <span class="comment">// DeltaFIFO is a Queue</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>从结构体中可以看到<code>DeltaFIFO</code>与<code>FIFO</code>的两处区别：</p>
<ul>
<li><code>item</code>中的value从<code>interface{}</code>变成了<code>Deltas</code>，<code>Deltas</code>是一个带有事件类型<code>DeltaType</code>的<code>interface{}</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaType is the type of a change (addition, deletion, etc)</span></span><br><span class="line"><span class="keyword">type</span> DeltaType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Added   DeltaType = <span class="string">"Added"</span></span><br><span class="line">	Updated DeltaType = <span class="string">"Updated"</span></span><br><span class="line">	Deleted DeltaType = <span class="string">"Deleted"</span></span><br><span class="line">	<span class="comment">// 新的list-watch周期产生的replace类型（list-watch期间可能会失败，触发重新list-watch）</span></span><br><span class="line">    <span class="comment">// 一般在执行Replace或者Resync操作的时候会产生</span></span><br><span class="line">	Sync DeltaType = <span class="string">"Sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 包含了变化类型的队列元素</span></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType</span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意Deltas是一个slice，也是这个资源产生的所有变化，Pop时出队的也是一整个slice</span></span><br><span class="line"><span class="comment">// 最新的变化在slice末尾</span></span><br><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br></pre></td></tr></table></figure>

<ul>
<li>多了一个<code>knownObjects</code>字段，其类型是<code>KeyListerGetter</code>这个接口，实际创建<code>DeltaFIFO</code>时这里传进来的是一个<code>cache</code>，由于<code>KeyListerGetter</code>只有<code>GetByKey</code>和<code>ListKeys</code>，因此<code>knownObjects</code>只具有读权限</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A KeyListerGetter is anything that knows how to list its keys and look up by key.</span></span><br><span class="line"><span class="keyword">type</span> KeyListerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	KeyLister</span><br><span class="line">	KeyGetter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A KeyLister is anything that knows how to list its keys.</span></span><br><span class="line"><span class="keyword">type</span> KeyLister <span class="keyword">interface</span> &#123;</span><br><span class="line">	ListKeys() []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A KeyGetter is anything that knows how to get the value stored under a given key.</span></span><br><span class="line"><span class="keyword">type</span> KeyGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetByKey(key <span class="keyword">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="如何创建-1"><a href="#如何创建-1" class="headerlink" title="如何创建"></a>如何创建</h4><p>创建一个<code>DeltaFIFO</code>除了要传入进行唯一索引值计算的<code>KeyFunc</code>以外，还需要传入实现了<code>KeyListerGetter</code>接口的对象。从前文的解析中可以发现，<code>Store</code>和<code>Indexer</code>中均实现了<code>KeyListerGetter</code>，由此不难想到这里传入的要么就是<code>Store</code>要么就是<code>Indexer</code>了。于是队列（<code>DeltaFIFO</code>）就和缓存（<code>cache</code>）链接了起来，这也是list-watch机制中至关重要的一个联系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeltaFIFO</span><span class="params">(keyFunc KeyFunc, knownObjects KeyListerGetter)</span> *<span class="title">DeltaFIFO</span></span> &#123;</span><br><span class="line">	f := &amp;DeltaFIFO&#123;</span><br><span class="line">		items:        <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas&#123;&#125;,</span><br><span class="line">		queue:        []<span class="keyword">string</span>&#123;&#125;,</span><br><span class="line">		keyFunc:      keyFunc,</span><br><span class="line">		knownObjects: knownObjects,</span><br><span class="line">	&#125;</span><br><span class="line">	f.cond.L = &amp;f.lock</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-3、实现的接口Queue"><a href="#1-2-3、实现的接口Queue" class="headerlink" title="1.2.3、实现的接口Queue"></a>1.2.3、实现的接口<code>Queue</code></h3><p>好，当前这一小节到目前为止都是在说队列的数据结构，其实外部传递的还是<code>FIFO</code>和<code>DeltaFIFO</code>实现的<code>Queue</code>这个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue是Store的一个拓展，具有队列的Pop功能</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">	Store</span><br><span class="line">    <span class="comment">// 当队列中没有元素时执行Pop会阻塞，直到有生产者往里面增加元素才会处理</span></span><br><span class="line">	<span class="comment">// 返回Pop出来的元素以及经过PopProcessFunc函数处理的结果，若PopProcessFunc处理失败会重新加入队列</span></span><br><span class="line">	<span class="comment">// type PopProcessFunc func(interface&#123;&#125;) error</span></span><br><span class="line">    <span class="comment">// 注意PopProcessFunc十分关键，这是我们使用list-watch真正能传进去的函数</span></span><br><span class="line">	Pop(PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	<span class="comment">// 当这个元素在队列中不存在时才会加入到队列中（注意跟Add的区别：Add会直接加入或刷新到队列中）</span></span><br><span class="line">	AddIfNotPresent(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// 判断第一批加进去的元素是否都已经处理完毕</span></span><br><span class="line">	HasSynced() <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 关闭这个队列，同时也会让对应的消费者关闭等待</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，辛辛苦苦讲一节，最终还是回到了原点：<code>Queue</code>其实是增加了队列功能的<code>Store</code>，相比而言只多了4个接口而已。关于<code>Store</code>接口可以看看上一节。另外还有一个关键的信息是，无论是<code>FIFO</code>还是<code>DeltaFIFO</code>，除了队列的操作以外，同<code>cache</code>一样也实现了<code>Store</code>接口。</p>
<h3 id="1-2-4、和cache-FIFO的比较"><a href="#1-2-4、和cache-FIFO的比较" class="headerlink" title="1.2.4、和cache/FIFO的比较"></a>1.2.4、和<code>cache</code>/<code>FIFO</code>的比较</h3><h4 id="1-2-4-1、结构体成员的区别"><a href="#1-2-4-1、结构体成员的区别" class="headerlink" title="1.2.4.1、结构体成员的区别"></a>1.2.4.1、结构体成员的区别</h4><p>这里先对比一下<code>cache</code>结构体：</p>
<ul>
<li>cache中有<code>indexers</code> 和<code>indices</code>来实现同类型资源的分类功能，FIFO/DeltaFIFO中没有，也无需处理</li>
<li>FIFO/DeltaFIFO中同样需要有map来保存所有的原始数据</li>
<li>FIFO/DeltaFIFO中多了一个通过slice实现的queue队列，这个队列中只保存需要处理的元素的key值，以减小队列的大小</li>
<li>FIFO中多了一个条件变量<code>sync.Cond</code>，用来做消息同步（Pop时如果队列为空则等待有新元素加入的消息）</li>
<li>DeltaFIFO相较于FIFO而言map中的值（<code>Deltas</code>）不一样，可以处理元素的操作类型，甚至可以处理元素的删除事件，并且当执行Pop出队时返回的是一个slice，</li>
<li>DeltaFIFO相较于FIFO多了一个knownObjects，这个在list-watch的时候十分重要，一旦某个周期中的list-watch失败了，会触发新的list-watch周期，在这个周期的开始阶段，会list一把最新的资源，并更新队列中的所有数据</li>
</ul>
<table>
<thead>
<tr>
<th>cache</th>
<th>FIFO</th>
<th>DeltaFIFO</th>
</tr>
</thead>
<tbody><tr>
<td>lock  sync.RWMutex</td>
<td>lock sync.RWMutex</td>
<td>lock sync.RWMutex</td>
</tr>
<tr>
<td>items map[string]interface{}</td>
<td>items map[string]interface{}</td>
<td>items map[string]<strong>Deltas</strong></td>
</tr>
<tr>
<td>keyFunc KeyFunc</td>
<td>keyFunc KeyFunc</td>
<td>keyFunc KeyFunc</td>
</tr>
<tr>
<td>indexers Indexers</td>
<td>cond sync.Cond</td>
<td>cond sync.Cond</td>
</tr>
<tr>
<td>indices Indices</td>
<td>queue []string</td>
<td>queue []string</td>
</tr>
<tr>
<td></td>
<td>populated bool</td>
<td>populated bool</td>
</tr>
<tr>
<td></td>
<td>initialPopulationCount int</td>
<td>initialPopulationCount int</td>
</tr>
<tr>
<td></td>
<td>closed bool</td>
<td>closed bool</td>
</tr>
<tr>
<td></td>
<td>closedLock sync.Mutex</td>
<td>closedLock sync.Mutex</td>
</tr>
<tr>
<td></td>
<td></td>
<td>knownObjects KeyListerGetter</td>
</tr>
</tbody></table>
<h4 id="1-2-4-2、接口实现的区别"><a href="#1-2-4-2、接口实现的区别" class="headerlink" title="1.2.4.2、接口实现的区别"></a>1.2.4.2、接口实现的区别</h4><p>我们对比一下目前已经讲过的几个接口：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>ThreadSafeStore</th>
<th>Store</th>
<th>Indexer</th>
<th>Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>ThreadSafeStore的接口</td>
<td>继承并增加了<code>KeyFunc</code></td>
<td>实现了<code>Store</code></td>
<td>实现<code>Store</code></td>
</tr>
<tr>
<td></td>
<td>NA</td>
<td>NA</td>
<td>增加了索引功能</td>
<td>增加了队列功能</td>
</tr>
<tr>
<td>结构体</td>
<td>threadSafeMap</td>
<td>cache/FIFO/DeltaFIFO</td>
<td>cache</td>
<td>FIFO/DeltaFIFO</td>
</tr>
</tbody></table>
<p>可以看到，实现了<code>Indexer</code>和<code>Queue</code>接口的对象其实也实现了<code>Store</code>接口，因此<code>FIFO</code>和<code>DeltaFIFO</code>也都实现了<code>Store</code>的接口。但是与<code>cache</code>不同的是，<code>FIFO</code>和<code>DeltaFIFO</code>所实现的<code>Store</code>中的<code>Resync()</code>和<code>Replace()</code>完全不同，可以看到<code>Resync()</code>其实是专门为队列设计的：</p>
<table>
<thead>
<tr>
<th>Store接口</th>
<th><code>cache</code></th>
<th><code>FIFO</code></th>
<th><code>DeltaFIFO</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Replace()</code></td>
<td>重建items和indices</td>
<td>更新items和queue</td>
<td>更新items和queue（该删的删）</td>
</tr>
<tr>
<td><code>Resync()</code></td>
<td>无具体实现</td>
<td>同步items与queue</td>
<td>同步items与queue</td>
</tr>
</tbody></table>
<p>这里其实需要重点讲一下<code>DeltaFIFO</code>的<code>Replace()</code>和<code>Resync()</code>，建议大家去看看实际的代码实现：</p>
<ul>
<li><code>Replace(list []interface{})</code>：将新的list全部以”Sync”事件加入到队列中（即使这个元素不在当前队列中），然后将新的list中已经没有的元素增加其”Deleted”事件（这个过程比较有意思，如果<code>DeltaFIFO</code>的<code>knownObjects</code>不为空就遍历<code>knownObjects</code>，否则遍历<code>DeltaFIFO</code>的<code>items</code>，list中没有就”Deleted”）</li>
<li><code>Resync()</code>：如果<code>DeltaFIFO</code>的<code>knownObjects</code>为空就直接返回，如果不为空则将<code>knownObjects</code>中的所有元素以”Sync”事件加入到队列中（估计是因为有这个机制，所以<code>Replace</code>中优先使用<code>knownObjects</code>来遍历）</li>
</ul>
<h4 id="1-2-4-3、功能的区别"><a href="#1-2-4-3、功能的区别" class="headerlink" title="1.2.4.3、功能的区别"></a>1.2.4.3、功能的区别</h4><p>通过结构体和接口实现的区别不难窥见：</p>
<ul>
<li><code>cache</code>用来存放最新的全量数据（无论是否变化）</li>
<li><code>FIFO</code>/<code>DeltaFIFO</code>用来存放变化（增/删/改/同步）的数据</li>
</ul>
<p>也就是说，<code>cache</code>中存放的是list出来的所有数据（很多数据可能是一直没有修改），<code>FIFO</code>/<code>DeltaFIFO</code>中存放的是watch到的变化（增删改）并且是需要去做对应处理的数据，这一点对于理解为什么要同时有<code>cache</code>/<code>FIFO</code>/<code>DeltaFIFO</code>这几个结构体、<code>Store</code>/<code>Indexer</code>/<code>Queue</code>这几个接口十分重要，后面讲到的关键数据结构<code>Reflector</code>和<code>Informer</code>也依赖于前面的这些基本的数据结构和接口。这时候你可能已经猜到这几个基本数据结构在整个list-watch中的角色了，我们接着往下看。</p>
<h3 id="1-2-5、总结"><a href="#1-2-5、总结" class="headerlink" title="1.2.5、总结"></a>1.2.5、总结</h3><p>这一章节我们讲到的是生产者消费者中最关键的数据结构<strong>队列</strong>，包含<code>FIFO</code>和<code>DeltaFIFO</code>，其本质都是一个<code>slice</code>，两者在结构上稍微有些差别：</p>
<ul>
<li><code>DeltaFIFO</code>比<code>FIFO</code>多了元素的操作类型，因此可以根据元素的增删改作出不同的处理</li>
<li><code>DeltaFIFO</code>会保存同一个元素的所有操作历史（相同操作会去重），FIFO只会保留元素最新的状态</li>
<li><code>DeltaFIFO</code>的<code>Pop</code>函数中传入的<code>PopProcessFunc</code>可以对元素的增删改作出不同的处理，FIFO则只能处理最新的</li>
</ul>
<p>除了<code>FIFO</code>和<code>DeltaFIFO</code>以外，我们还讲到了这两个对象实现了的接口<code>Queue</code>，本质上<code>Queue</code>是一个实现了队列操作的<code>Store</code>。</p>
<blockquote>
<p>了解完队列相关的数据结构，你是不是对后面可能要讲到的内容有一定的预期了呢？</p>
<p>1.1节讲到的cache用来做全量资源的缓存，1.2节讲到的队列用来处理增删改的事件，这些都是list-watch的生产者消费者框架中重要的数据结构，那么一定有其他的数据结构和算法来把他们组织起来，从之前了解到的list-watch的client端画像来看，这个client一定有段逻辑来维护cache这个全量缓存并通过队列来把生产者与消费者组织起来。</p>
<p>我们不妨大胆做一个猜测：可能是先到server端全量list一把，然后存到cache中，剩下的事情就是从server端不断watch新的变化并加入到队列中，这个队列的消费者那里除了将变化更新到cache中之外，还会对这个变化做出相应的处理。</p>
</blockquote>
<h2 id="1-3、关键数据结构Informer和Reflector"><a href="#1-3、关键数据结构Informer和Reflector" class="headerlink" title="1.3、关键数据结构Informer和Reflector"></a>1.3、关键数据结构<code>Informer</code>和<code>Reflector</code></h2><p>1.1和1.2章节讲到的都是生产者消费者模型中最基本的数据结构，接下来我们要讨论的是将生产者消费者模型组织起来的关键数据结构<code>informer</code>和<code>reflector</code>，这也是在k8s的client中直接使用的数据结构，其中会使用到我们前面讲到的基础数据结构。</p>
<blockquote>
<p>这里有必要提前说明一下informer、reflector、Indexer这几者的区别：<a href="https://www.huweihuang.com/kubernetes-notes/code-analysis/kube-controller-manager/sharedIndexInformer.html" target="_blank" rel="noopener">参考资料</a></p>
<ul>
<li><code>Reflector</code>：reflector用来watch特定的k8s API资源。具体的实现是通过<code>ListAndWatch</code>的方法，watch可以是k8s内建的资源或者是自定义的资源。当reflector通过watch API接收到有关新资源实例存在的通知时，它使用相应的列表API获取新创建的对象，并将其放入watchHandler函数内的DeltaFIFO队列中。</li>
<li><code>Informer</code>：informer从DeltaFIFO队列中弹出对象。执行此操作的功能是processLoop。base controller的作用是保存对象以供以后检索，并调用我们的控制器将对象传递给它。</li>
<li><code>Indexer</code>：索引器提供对象的索引功能。典型的索引用例是基于对象标签创建索引。 Indexer可以根据多个索引函数维护索引。Indexer使用线程安全的数据存储来存储对象及其键。 在Store中定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数生成对象的键作为该对象的<code>&lt;namespace&gt; / &lt;name&gt;</code>组合。</li>
</ul>
<p>也就是说，reflector是真正的生产者，informer则是消费者，由此可以推测reflector中一定有队列，informer中一定有逻辑来调用这个队列的Pop函数来进行处理。</p>
</blockquote>
<h3 id="1-3-1、Reflector"><a href="#1-3-1、Reflector" class="headerlink" title="1.3.1、Reflector"></a>1.3.1、<code>Reflector</code></h3><p>我们先来看<code>Reflector</code>的结构体，之前已经说到<code>Reflector</code>是生产者，那么它的数据结构是什么样的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflector仅监听一种k8s资源的变化并放置到存储器（队列）中</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// reflector的名称，默认情况下是以调用NewReflector函数的代码file:line为名称</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// metrics tracks basic metric information about the reflector</span></span><br><span class="line">	metrics *reflectorMetrics</span><br><span class="line">	<span class="comment">// 监听的资源类型，之所以这个结构体称为Reflector，主要就是能反射所有的资源类型，只要你定义好</span></span><br><span class="line">    <span class="comment">// 需要注意的是，这里的资源类型</span></span><br><span class="line">	expectedType reflect.Type</span><br><span class="line">	<span class="comment">// 存储器（本质上是DeltaFIFO队列），也是生产者和消费者之间的桥梁</span></span><br><span class="line">	store Store</span><br><span class="line">	<span class="comment">// 真正的生产者函数，其本质是调用kube-apiserver的接口来list-watch这个资源</span></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// list-watch执行失败后重新list-watch的等待时间，默认为1秒</span></span><br><span class="line">	period       time.Duration </span><br><span class="line">    <span class="comment">// 在watch的过程中定期进行同步队列的周期（并非重新执行list操作的周期）</span></span><br><span class="line">	resyncPeriod time.Duration </span><br><span class="line">    <span class="comment">// 判断是否需要重新同步，watch的过程单独的协程中调用</span></span><br><span class="line">	ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> </span><br><span class="line">	<span class="comment">// clock allows tests to manipulate time</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line">	<span class="comment">// 最后一次同步时从kube-apiserver获取到的该资源的版本号，跟etcd中可能不一致</span></span><br><span class="line">    <span class="comment">// 无论是初次list还是后续不断的watch过程都会更新这个版本号</span></span><br><span class="line">	lastSyncResourceVersion <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion</span></span><br><span class="line">	lastSyncResourceVersionMutex sync.RWMutex</span><br><span class="line">	<span class="comment">// 初次list时进行分页的页大小，主要用来提升list的性能</span></span><br><span class="line">	WatchListPageSize <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是<code>Reflector</code>的所有成员变量，从中不难看出这些成员之间的配合关系，在此简单梳理一下<code>Reflector</code>实际的执行逻辑（即<code>Reflector</code>的<code>Run()</code>函数逻辑，代码位于staging/src/k8s.io/client-go/tools/cache/reflector.go）：</p>
<ul>
<li>首先list一把当前这个资源类型的所有数据，然后调用<code>DeltaFIFO</code>的<code>Replace()</code>将list到的新数据同步到队列中，并将当前的版本号记录到<code>lastSyncResourceVersion</code>中</li>
<li>起一个协程（收到stop信号或resync报错时退出），以<code>resyncPeriod</code>为周期，每次都通过<code>ShouldResync</code>函数判断（nil时默认执行）是否需要重新同步，是则将<code>DeltaFIFO</code>中的<code>knownObjects</code>（不为nil的情况下）遍历，并将<code>DeltaFIFO</code>队列中不存在的元素加入到队列中（<code>DeltaType</code>为<code>Sync</code>）</li>
<li>起一个死循环（收到stop信号时退出），watch对应类型的资源，一旦有新事件产生则调用<code>DeltaFIFO</code>的增删改接口加入到队列中去</li>
</ul>
<blockquote>
<p>值得注意的是，list只在watch之前执行一次，在watch的过程中并不会重新list，而只是会定期“整理”（<code>Resync()</code>，与<code>DeltaFIFO</code>中的<code>knownObjects</code>对比）队列中的元素。只有当watch报错时才会重新触发list-watch。</p>
</blockquote>
<p>由此可以看出，这个过程中除了watch到了应该关注的增删改事件之外，还产生了很多<code>DeltaType</code>为<code>Sync</code>的事件，为什么需要产生这中类型的事件？这些事件是如何处理的呢？另外<code>Reflector</code>究竟是在被谁使用？我们且带着疑问继续往下看~</p>
<p><code>Reflector</code>的<code>Run()</code>函数逻辑（可以跳过）</p>
<h4 id="如何创建-2"><a href="#如何创建-2" class="headerlink" title="如何创建"></a>如何创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewNamedReflector same as NewReflector, but with a specified name for logging</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamedReflector</span><span class="params">(name <span class="keyword">string</span>, lw ListerWatcher, expectedType <span class="keyword">interface</span>&#123;&#125;, store Store, resyncPeriod time.Duration)</span> *<span class="title">Reflector</span></span> &#123;</span><br><span class="line">	r := &amp;Reflector&#123;</span><br><span class="line">		name:          name,</span><br><span class="line">		listerWatcher: lw,</span><br><span class="line">		store:         store,</span><br><span class="line">		expectedType:  reflect.TypeOf(expectedType),</span><br><span class="line">		period:        time.Second,</span><br><span class="line">		resyncPeriod:  resyncPeriod,</span><br><span class="line">		clock:         &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2、Controller"><a href="#1-3-2、Controller" class="headerlink" title="1.3.2、Controller"></a>1.3.2、<code>Controller</code></h3><p>前面讲到了<code>Reflector</code>是生产者，<code>Informer</code>是消费者，但是中间需要有一个桥梁来将两者关联起来，而这个角色就是<code>Controller</code>来扮演的，它会将生产者和消费者都运行起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller is a generic controller framework.</span></span><br><span class="line"><span class="keyword">type</span> controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	config         Config <span class="comment">// 主要是里面的配置文件</span></span><br><span class="line">	reflector      *Reflector <span class="comment">// controller中的Reflector</span></span><br><span class="line">	reflectorMutex sync.RWMutex</span><br><span class="line">	clock          clock.Clock</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Controller中最重要的是Run函数</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)  <span class="comment">// controller实际执行的函数</span></span><br><span class="line">	HasSynced() <span class="keyword">bool</span> <span class="comment">// 队列中是否已经同步过了（没有sync或者第一批加进去的元素）</span></span><br><span class="line">	LastSyncResourceVersion() <span class="keyword">string</span> <span class="comment">// 返回资源最近一次的版本号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Config contains all the settings for a Controller.</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 这个controller中的队列，给reflector用的</span></span><br><span class="line">	Queue</span><br><span class="line">	<span class="comment">// 给kube-apiserver发送list-watch请求的函数</span></span><br><span class="line">	ListerWatcher</span><br><span class="line">    <span class="comment">// 队列中的元素Pop()后对其进行处理的函数，Pop(PopProcessFunc) (interface&#123;&#125;, error)</span></span><br><span class="line">	Process ProcessFunc</span><br><span class="line">	<span class="comment">// 要处理的对象的类型（也就是说一个controller只能处理一种类型的资源）</span></span><br><span class="line">	ObjectType runtime.Object</span><br><span class="line">	<span class="comment">// Reprocess everything at least this often.</span></span><br><span class="line">	<span class="comment">// Note that if it takes longer for you to clear the queue than this</span></span><br><span class="line">	<span class="comment">// period, you will end up processing items in the order determined</span></span><br><span class="line">	<span class="comment">// by FIFO.Replace(). Currently, this is random. If this is a</span></span><br><span class="line">	<span class="comment">// problem, we can change that replacement policy to append new</span></span><br><span class="line">	<span class="comment">// things to the end of the queue instead of replacing the entire</span></span><br><span class="line">	<span class="comment">// queue.</span></span><br><span class="line">	FullResyncPeriod time.Duration</span><br><span class="line">	<span class="comment">// 其实就是传给reflector的ShouldResync函数</span></span><br><span class="line">	ShouldResync ShouldResyncFunc</span><br><span class="line">	<span class="comment">// 是则每次处理失败将元素重新入队</span></span><br><span class="line">	RetryOnError <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Controller</code>中的运行逻辑比较简单，这里我们直接用代码说明一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run中创建一个reflector并起一个协程将其Run起来，然后不停执行processLoop用来Pop队列中的元素并处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果收到了stopCh的信号，则将队列关闭</span></span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// 使用config中的参数先创建一个reflector</span></span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.clock = c.clock</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()</span><br><span class="line">	<span class="comment">// 新起一个协程来执行reflector的Run函数（通过调用kube-apiserver的接口将元素加入到队列中）</span></span><br><span class="line">    <span class="comment">// 实际是生产者，会将生产出来的数据放入到Queue中</span></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">    <span class="comment">// 不断执行processLoop函数来对队列中的元素进行Pop和处理</span></span><br><span class="line">    <span class="comment">// 实际是消费者</span></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// processLoop是处理队列中元素的消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 将队列中的元素Pop出来并使用c.config.Process中的函数进行处理</span></span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == FIFOClosedError &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// 如果设置了RetryOnError则重新入队</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到从<code>reflector</code>到<code>controller</code>都是生产者这边对队列的入队处理以及消费者对出队元素的处理，并没有看到全量缓存的踪迹，其实这个是要留给<code>Informer</code>来做的，另外对队列中Pop出来的元素进行处理也是config中的Process函数的事情，这个处理函数也是<code>Informer</code>中定义的。</p>
<h3 id="1-3-3、Informer"><a href="#1-3-3、Informer" class="headerlink" title="1.3.3、Informer"></a>1.3.3、<code>Informer</code></h3><p>我们先看一下<code>Informer</code>的结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedIndexInformer <span class="keyword">struct</span> &#123;</span><br><span class="line">	indexer    Indexer  <span class="comment">// 本质上就是一个cache，是本地的全量数据缓存</span></span><br><span class="line">	controller Controller  <span class="comment">// 前文提到的controller，里面包含了Reflector</span></span><br><span class="line">	processor             *sharedProcessor <span class="comment">// 针对各个事件的处理函数，一个informer中可以有多个</span></span><br><span class="line">	cacheMutationDetector CacheMutationDetector <span class="comment">// 突变检查器，当发现前后数据突变时直接panic，默认情况下并未开启</span></span><br><span class="line">	listerWatcher ListerWatcher  <span class="comment">// 生产者，client发送http请求list-watch apiserver的client</span></span><br><span class="line">	objectType    runtime.Object  <span class="comment">// 处理的资源类型，注意一个informer也只能处理一种k8s资源类型</span></span><br><span class="line">	<span class="comment">// resyncCheckPeriod is how often we want the reflector's resync timer to fire so it can call</span></span><br><span class="line">	<span class="comment">// shouldResync to check if any of our listeners need a resync.</span></span><br><span class="line">	resyncCheckPeriod time.Duration</span><br><span class="line">	<span class="comment">// EventHandler中默认的同步周期，添加EventHandler时如果没有指定就使用这个</span></span><br><span class="line">	defaultEventHandlerResyncPeriod time.Duration</span><br><span class="line">	<span class="comment">// clock主要是用来测试的</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line">    <span class="comment">// 用于标示这个informer是否已经开始或者已经停止，processor处理的时候会做一些调整</span></span><br><span class="line">	started, stopped <span class="keyword">bool</span></span><br><span class="line">	startedLock      sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// blockDeltas gives a way to stop all event distribution so that a late event handler</span></span><br><span class="line">	<span class="comment">// can safely join the shared informer.</span></span><br><span class="line">	blockDeltas sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SharedInformer has a shared data cache and is capable of distributing notifications for changes</span></span><br><span class="line"><span class="comment">// to the cache to multiple listeners who registered via AddEventHandler. If you use this, there is</span></span><br><span class="line"><span class="comment">// one behavior change compared to a standard Informer.  When you receive a notification, the cache</span></span><br><span class="line"><span class="comment">// will be AT LEAST as fresh as the notification, but it MAY be more fresh.  You should NOT depend</span></span><br><span class="line"><span class="comment">// on the contents of the cache exactly matching the notification you've received in handler</span></span><br><span class="line"><span class="comment">// functions.  If there was a create, followed by a delete, the cache may NOT have your item.  This</span></span><br><span class="line"><span class="comment">// has advantages over the broadcaster since it allows us to share a common cache across many</span></span><br><span class="line"><span class="comment">// controllers. Extending the broadcaster would have required us keep duplicate caches for each</span></span><br><span class="line"><span class="comment">// watch.</span></span><br><span class="line"><span class="keyword">type</span> SharedInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// AddEventHandler adds an event handler to the shared informer using the shared informer's resync</span></span><br><span class="line">	<span class="comment">// period.  Events to a single handler are delivered sequentially, but there is no coordination</span></span><br><span class="line">	<span class="comment">// between different handlers.</span></span><br><span class="line">	AddEventHandler(handler ResourceEventHandler)</span><br><span class="line">	<span class="comment">// AddEventHandlerWithResyncPeriod adds an event handler to the shared informer using the</span></span><br><span class="line">	<span class="comment">// specified resync period.  Events to a single handler are delivered sequentially, but there is</span></span><br><span class="line">	<span class="comment">// no coordination between different handlers.</span></span><br><span class="line">	AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)</span><br><span class="line">	<span class="comment">// GetStore获取缓存接口（cache的Store接口）</span></span><br><span class="line">	GetStore() Store</span><br><span class="line">	<span class="comment">// GetController gives back a synthetic interface that "votes" to start the informer</span></span><br><span class="line">	GetController() Controller</span><br><span class="line">	<span class="comment">// Run starts the shared informer, which will be stopped when stopCh is closed.</span></span><br><span class="line">	Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// HasSynced returns true if the shared informer's store has synced.</span></span><br><span class="line">	HasSynced() <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// LastSyncResourceVersion is the resource version observed when last synced with the underlying</span></span><br><span class="line">	<span class="comment">// store. The value returned is not synchronized with access to the underlying store and is not</span></span><br><span class="line">	<span class="comment">// thread-safe.</span></span><br><span class="line">	LastSyncResourceVersion() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SharedIndexInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	SharedInformer</span><br><span class="line">	<span class="comment">// AddIndexers add indexers to the informer before it starts.</span></span><br><span class="line">	AddIndexers(indexers Indexers) error</span><br><span class="line">	GetIndexer() Indexer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="comment">// 创建一个DeltaFIFO，以&lt;namespace&gt;/&lt;name&gt;作为索引的key，将indexer作为knownObjects进行同步</span></span><br><span class="line">    <span class="comment">// 注意到s.indexer到了DeltaFIFO那边之后只是作为全量的参考，用于DeltaFIFO做Replace/Resync</span></span><br><span class="line">    <span class="comment">// 实际s.indexer是informer自己在维护，DeltaFIFO只做ListKeys和GetByKey</span></span><br><span class="line">	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, s.indexer)</span><br><span class="line">    <span class="comment">// 创建controller中用到的Config</span></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		ListerWatcher:    s.listerWatcher,</span><br><span class="line">		ObjectType:       s.objectType,</span><br><span class="line">		FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">		ShouldResync:     s.processor.shouldResync,</span><br><span class="line">        <span class="comment">// 这实际是传给DeltaFIFO的Pop()的处理函数，也就是实际处理队列元素的函数</span></span><br><span class="line">        <span class="comment">// HandleDeltas中维护缓存（Indexer）中的数据并把消息（实际也是这个元素）发送给处理函数</span></span><br><span class="line">		Process: s.HandleDeltas,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 那么问题来了，这里为什么要写成闭包呢？</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">        <span class="comment">// 通过前面生成的cfg创建informer中的controller</span></span><br><span class="line">		s.controller = New(cfg)</span><br><span class="line">		s.controller.(*controller).clock = s.clock</span><br><span class="line">		s.started = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里主要是让主进程要结束的时候通知下面两个协程也退出并且等待这两个协程退出之后再退出主进程</span></span><br><span class="line">	processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    <span class="comment">// 注意processor是通过AddEventHandler添加进来的，这里是执行这些Handler</span></span><br><span class="line">    <span class="comment">// 前面提到的s.HandleDeltas里面把要处理的元素放在chanel里面，processor执行的时候等待这个chanel</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// 让controller运行起来，这个Run函数中会创建reflector并起一个协程来进行list-watch，这个协程中会将watch到的变化加入到队列中，主进程中不停进行Pop操作并调用s.HandleDeltas对出队的元素进行处理</span></span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-4、总结"><a href="#1-3-4、总结" class="headerlink" title="1.3.4、总结"></a>1.3.4、总结</h3><h2 id="1-4、各个k8s资源的informer实现"><a href="#1-4、各个k8s资源的informer实现" class="headerlink" title="1.4、各个k8s资源的informer实现"></a>1.4、各个k8s资源的informer实现</h2><h1 id="2、关键运行流程"><a href="#2、关键运行流程" class="headerlink" title="2、关键运行流程"></a>2、关键运行流程</h1><p>NewSharedInformerFactory</p>
<ol>
<li>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</li>
<li>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</li>
<li>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</li>
<li>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</li>
<li>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</li>
<li>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</li>
<li>DeltaFIFO 再 Pop 这个事件到 Controller 中</li>
<li>Controller 收到这个事件，会触发 Processor 的回调函数</li>
<li>LocalStore 会周期性地把所有的 Pod 信息重新放到 DeltaFIFO 中</li>
</ol>
<p><img src="http://o6sfmikvw.bkt.clouddn.com/listwatch.png" alt="img"></p>
<p><img src="/2019/08/01/inside-list-watch-in-k8s/client-go-controller-interaction.jpg" alt="img"></p>
<h1 id="3、如何写一个自定义的controller"><a href="#3、如何写一个自定义的controller" class="headerlink" title="3、如何写一个自定义的controller"></a>3、如何写一个自定义的controller</h1><h1 id="4、List-Watch中的设计理念"><a href="#4、List-Watch中的设计理念" class="headerlink" title="4、List-Watch中的设计理念"></a>4、List-Watch中的设计理念</h1><h2 id="4-1、合理利用计算和存储资源，功夫下在每分每秒"><a href="#4-1、合理利用计算和存储资源，功夫下在每分每秒" class="headerlink" title="4.1、合理利用计算和存储资源，功夫下在每分每秒"></a>4.1、合理利用计算和存储资源，功夫下在每分每秒</h2><p><code>threadSafeMap</code>中的<code>indices</code>这个map的维护是深得这一理念的真传：</p>
<ul>
<li><strong>增删改</strong>的时候维护好分类好的芸芸众生（功夫下在平时，多消耗一点计算和存储资源）</li>
<li><strong>查</strong>的时候直接按照分类返回同类（响应时间）</li>
</ul>
<p>这个跟微信达人们使用微信分组是多么像啊：</p>
<ul>
<li>平时管理好友时做好分组</li>
<li>发朋友圈时直接选择可见的分组</li>
</ul>
<h2 id="4-2、封装，接着封装"><a href="#4-2、封装，接着封装" class="headerlink" title="4.2、封装，接着封装"></a>4.2、封装，接着封装</h2><p>几个断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewThreadSafeStore</span><span class="params">(indexers Indexers, indices Indices)</span> <span class="title">ThreadSafeStore</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;threadSafeMap&#123;</span><br><span class="line">		items:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		indexers: indexers,</span><br><span class="line">		indices:  indices,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于确认cache实现了Store的所有接口，否则编译会出错</span></span><br><span class="line"><span class="keyword">var</span> _ Store = &amp;cache&#123;&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewStore returns a Store implemented simply with a map and a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(keyFunc KeyFunc)</span> <span class="title">Store</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">		cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),</span><br><span class="line">		keyFunc:      keyFunc,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span> <span class="title">Indexer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">		cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">		keyFunc:      keyFunc,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	_ = Queue(&amp;FIFO&#123;&#125;) <span class="comment">// FIFO is a Queue</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	_ = Queue(&amp;DeltaFIFO&#123;&#125;) <span class="comment">// DeltaFIFO is a Queue</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>yost
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yost.top/2019/08/01/inside-list-watch-in-k8s/" title="深入理解k8s中的list-watch机制">http://yost.top/2019/08/01/inside-list-watch-in-k8s/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/list-watch-k8s-client-go/" rel="tag"># list-watch, k8s, client-go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/16/how-to-analysis-commit/" rel="prev" title="如何整理和分析commit">
      <i class="fa fa-chevron-left"></i> 如何整理和分析commit
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/26/leetcode-review/" rel="next" title="leetcode题解持续更新">
      leetcode题解持续更新 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0、啥是list-watch"><span class="nav-text">0、啥是list-watch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1、list与watch"><span class="nav-text">0.1、list与watch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-2、使用场景"><span class="nav-text">0.2、使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-3、代码目录"><span class="nav-text">0.3、代码目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-4、list-watch的架构"><span class="nav-text">0.4、list-watch的架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1、数据结构"><span class="nav-text">1、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、基础数据结构threadSafeMap和cache"><span class="nav-text">1.1、基础数据结构threadSafeMap和cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1、threadSafeMap"><span class="nav-text">1.1.1、threadSafeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-1、实现的接口ThreadSafeStore"><span class="nav-text">1.1.1.1、实现的接口ThreadSafeStore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-2、如何创建"><span class="nav-text">1.1.1.2、如何创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2、cache"><span class="nav-text">1.1.2、cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-1、实现的接口Store"><span class="nav-text">1.1.2.1、实现的接口Store</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-2、实现的接口Indexer"><span class="nav-text">1.1.2.2、实现的接口Indexer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-3、如何创建"><span class="nav-text">1.1.2.3、如何创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3、总结"><span class="nav-text">1.1.3、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、基础数据结构FIFO和DeltaFIFO"><span class="nav-text">1.2、基础数据结构FIFO和DeltaFIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1、FIFO"><span class="nav-text">1.2.1、FIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建"><span class="nav-text">如何创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2、DeltaFIFO"><span class="nav-text">1.2.2、DeltaFIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建-1"><span class="nav-text">如何创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3、实现的接口Queue"><span class="nav-text">1.2.3、实现的接口Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4、和cache-FIFO的比较"><span class="nav-text">1.2.4、和cache&#x2F;FIFO的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-1、结构体成员的区别"><span class="nav-text">1.2.4.1、结构体成员的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-2、接口实现的区别"><span class="nav-text">1.2.4.2、接口实现的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-3、功能的区别"><span class="nav-text">1.2.4.3、功能的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5、总结"><span class="nav-text">1.2.5、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3、关键数据结构Informer和Reflector"><span class="nav-text">1.3、关键数据结构Informer和Reflector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1、Reflector"><span class="nav-text">1.3.1、Reflector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建-2"><span class="nav-text">如何创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2、Controller"><span class="nav-text">1.3.2、Controller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3、Informer"><span class="nav-text">1.3.3、Informer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4、总结"><span class="nav-text">1.3.4、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4、各个k8s资源的informer实现"><span class="nav-text">1.4、各个k8s资源的informer实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、关键运行流程"><span class="nav-text">2、关键运行流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、如何写一个自定义的controller"><span class="nav-text">3、如何写一个自定义的controller</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、List-Watch中的设计理念"><span class="nav-text">4、List-Watch中的设计理念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1、合理利用计算和存储资源，功夫下在每分每秒"><span class="nav-text">4.1、合理利用计算和存储资源，功夫下在每分每秒</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2、封装，接着封装"><span class="nav-text">4.2、封装，接着封装</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yost</p>
  <div class="site-description" itemprop="description">种一棵树最好的时间是十年前，其次是现在~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yost</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='50' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
