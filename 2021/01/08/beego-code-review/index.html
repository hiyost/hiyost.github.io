<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yost.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="最近在给前端做概览接口，发现之前设计的excution之类的API比较难做这个概览，在走读apiserver的代码时发现之前了解的beego相关的知识已经不足以支撑自己做一些重构或者特性了，主要是面对多个controller的时候没有找到一个比较好的方法去设计接口来聚合，因此趁此机会好好走读一下beego的代码，当前业务中使用的都是beego 1.12.2的代码，因此本文也以这个版本作为基线（虽然">
<meta property="og:type" content="article">
<meta property="og:title" content="beego代码分析">
<meta property="og:url" content="http://yost.top/2021/01/08/beego-code-review/index.html">
<meta property="og:site_name" content="yost">
<meta property="og:description" content="最近在给前端做概览接口，发现之前设计的excution之类的API比较难做这个概览，在走读apiserver的代码时发现之前了解的beego相关的知识已经不足以支撑自己做一些重构或者特性了，主要是面对多个controller的时候没有找到一个比较好的方法去设计接口来聚合，因此趁此机会好好走读一下beego的代码，当前业务中使用的都是beego 1.12.2的代码，因此本文也以这个版本作为基线（虽然">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-08T02:23:22.000Z">
<meta property="article:modified_time" content="2021-04-11T13:03:03.176Z">
<meta property="article:author" content="yost">
<meta property="article:tag" content="beego">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yost.top/2021/01/08/beego-code-review/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>beego代码分析 | yost</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yost</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yost.top/2021/01/08/beego-code-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yost">
      <meta itemprop="description" content="种一棵树最好的时间是十年前，其次是现在~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yost">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          beego代码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 10:23:22" itemprop="dateCreated datePublished" datetime="2021-01-08T10:23:22+08:00">2021-01-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最近在给前端做概览接口，发现之前设计的excution之类的API比较难做这个概览，在走读apiserver的代码时发现之前了解的beego相关的知识已经不足以支撑自己做一些重构或者特性了，主要是面对多个controller的时候没有找到一个比较好的方法去设计接口来聚合，因此趁此机会好好走读一下beego的代码，当前业务中使用的都是beego 1.12.2的代码，因此本文也以这个版本作为基线（虽然beego 2.0已经发布有一段时日了）。</p>
<h3 id="1、-前言"><a href="#1、-前言" class="headerlink" title="1、 前言"></a>1、 前言</h3><p>在分析beego的代码之前，我们需要先了解beego到底做了什么，根据beego的<a href="https://beego.me/docs/intro/" target="_blank" rel="noopener">官方介绍</a>：</p>
<blockquote>
<p>beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。</p>
</blockquote>
<p>从中不难看出，beego的本质还是一个http框架，用来搭建一个http server。要知道，Go语言的http库已经非常强大了，启动一个简单的server代码在10行左右就能搞定，既然如此，我们来对比一下使用Go官方的http库和使用beego分别启动，看看两者的差别。我们的要求如下：</p>
<ul>
<li>在本地的8080端口启动一个server，对于”/hello”这个路由的GET请求返回”Hello world!”</li>
</ul>
<h4 id="1-1、使用http库实现"><a href="#1-1、使用http库实现" class="headerlink" title="1.1、使用http库实现"></a>1.1、使用http库实现</h4><p>以下是直接使用http库来实现的server，可以看到，寥寥几句确实简洁无比。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 自定义一个Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> r.Method &#123;</span><br><span class="line">	<span class="keyword">case</span> http.MethodGet:</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Hello world!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1、注册Handler</span></span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>, indexHandler)</span><br><span class="line">    <span class="comment">// 2、启动server</span></span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的http库是一个十分值得仔细研究的库，可以参考<a href>官方文档</a>，关于http server的部分也可以参考<a href="https://juejin.cn/post/6844903998869209095" target="_blank" rel="noopener">深入理解Golang之http server</a>。</p>
<h4 id="1-2、使用beego来实现"><a href="#1-2、使用beego来实现" class="headerlink" title="1.2、使用beego来实现"></a>1.2、使用beego来实现</h4><p>使用beego来注册路由时可以控制的更加精细，譬如可以在注册时针对不同的请求动作（GET/POST/DELETE/…）来注册不同的方法。而http库就需要在Handler中通过请求的动作来分别处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个controller类型</span></span><br><span class="line"><span class="keyword">type</span> SampleController <span class="keyword">struct</span> &#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现一个方法作为处理的Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SampleController)</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	this.Ctx.WriteString(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1、初始化（注册）Handler，将SampleController这个类型的Hello方法作为/hello这个路由GET请求的处理Handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	beego.Router(<span class="string">"/hello"</span>, &amp;SampleController&#123;&#125;, <span class="string">"get:Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、启动server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，本质上beego还是http库的一个封装，最终还是由http库中的各个类型和接口来实现的。</p>
<h3 id="2、代码剖析"><a href="#2、代码剖析" class="headerlink" title="2、代码剖析"></a>2、代码剖析</h3><h4 id="2-1、注册路由"><a href="#2-1、注册路由" class="headerlink" title="2.1、注册路由"></a>2.1、注册路由</h4><h5 id="2-1-1、Router函数"><a href="#2-1-1、Router函数" class="headerlink" title="2.1.1、Router函数"></a>2.1.1、<code>Router</code>函数</h5><p>从前面样例中可以看到，在注册一个路由之前，需要先定义好这个路由对应的类型<code>SampleController</code>以及其使用的方法<code>Hello()</code>。这个类型内嵌了<code>beego.Controller</code>，其结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/controller.go</span></span><br><span class="line"><span class="comment">// Controller defines some basic http request handler operations, such as</span></span><br><span class="line"><span class="comment">// http context, template and view, session and xsrf.</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// http ctx数据，beego的Context基于http.Context做了一层封装</span></span><br><span class="line">	Ctx  *context.Context</span><br><span class="line">	Data <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// route controller info</span></span><br><span class="line">	controllerName <span class="keyword">string</span>   <span class="comment">// 实例化的controller名字</span></span><br><span class="line">	actionName     <span class="keyword">string</span>   <span class="comment">// 需要执行的Controller的方法名</span></span><br><span class="line">	methodMapping  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> //<span class="title">method</span>:<span class="title">routertree</span></span></span><br><span class="line">	AppController  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// template data  // view相关的信息</span></span><br><span class="line">	TplName        <span class="keyword">string</span></span><br><span class="line">	ViewPath       <span class="keyword">string</span></span><br><span class="line">	Layout         <span class="keyword">string</span></span><br><span class="line">	LayoutSections <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// the key is the section name and the value is the template name</span></span><br><span class="line">	TplPrefix      <span class="keyword">string</span></span><br><span class="line">	TplExt         <span class="keyword">string</span></span><br><span class="line">	EnableRender   <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// xsrf data</span></span><br><span class="line">	_xsrfToken <span class="keyword">string</span></span><br><span class="line">	XSRFExpire <span class="keyword">int</span></span><br><span class="line">	EnableXSRF <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// session</span></span><br><span class="line">	CruSession session.Store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>beego.Controller</code>是一个过程中数据，每接收到一次请求，就会创建一个<code>beego.Controller</code>实例，生命周期与<code>http.Context</code>类似（其本质也是在<code>http.Context</code>的基础上做了进一步封装）。</p>
<p>接下来我们看注册的部分，<code>beego</code>中注册一个Handler时使用到的是<code>Router</code>函数，我们进入这个函数一探究竟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/app.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Router adds a patterned controller handler to BeeApp.</span></span><br><span class="line"><span class="comment">// it's an alias method of App.Router.</span></span><br><span class="line"><span class="comment">// Router支持以多种方式注册路由</span></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">//  simple router</span></span><br><span class="line"><span class="comment">//  beego.Router("/admin", &amp;admin.UserController&#123;&#125;)</span></span><br><span class="line"><span class="comment">//  beego.Router("/admin/index", &amp;admin.ArticleController&#123;&#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  regex router  // 正则路由</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  beego.Router("/api/:id([0-9]+)", &amp;controllers.RController&#123;&#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  custom rules</span></span><br><span class="line"><span class="comment">//  beego.Router("/api/list",&amp;RestController&#123;&#125;,"*:ListFood")</span></span><br><span class="line"><span class="comment">//  beego.Router("/api/create",&amp;RestController&#123;&#125;,"post:CreateFood")</span></span><br><span class="line"><span class="comment">//  beego.Router("/api/update",&amp;RestController&#123;&#125;,"put:UpdateFood")</span></span><br><span class="line"><span class="comment">//  beego.Router("/api/delete",&amp;RestController&#123;&#125;,"delete:DeleteFood")</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Router</span><span class="params">(rootpath <span class="keyword">string</span>, c ControllerInterface, mappingMethods ...<span class="keyword">string</span>)</span> *<span class="title">App</span></span> &#123;</span><br><span class="line">	BeeApp.Handlers.Add(rootpath, c, mappingMethods...)</span><br><span class="line">	<span class="keyword">return</span> BeeApp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Router</code>函数中，入参有3个：</p>
<ul>
<li><p><code>rootpath string</code>：路由的路径，可以是精准匹配，也可以是正则匹配，正则匹配时支持获取匹配的字符串内容，譬如正则路径是<code>/api/:id</code>，那么可以在对应的<code>Controller</code>中通过<code>c.Ctx.Input.Param(&quot;:id&quot;)</code>来获取；</p>
</li>
<li><p><code>c ControllerInterface</code>：对应于路由的处理方法，一般都是在<code>beego.Controller</code>这个类型的基础上内嵌实现，不过入参使用的是<code>beego.Controller</code>实现了的<code>ControllerInterface</code>这个接口</p>
<ul>
<li><p><code>ControllerInterface</code>接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/controller.go</span></span><br><span class="line"><span class="comment">// ControllerInterface is an interface to uniform all controller handler.</span></span><br><span class="line"><span class="keyword">type</span> ControllerInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Init(ct *context.Context, controllerName, actionName <span class="keyword">string</span>, app <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Prepare()</span><br><span class="line">	Get()</span><br><span class="line">	Post()</span><br><span class="line">	Delete()</span><br><span class="line">	Put()</span><br><span class="line">	Head()</span><br><span class="line">	Patch()</span><br><span class="line">	Options()</span><br><span class="line">	Trace()</span><br><span class="line">	Finish()</span><br><span class="line">	Render() error</span><br><span class="line">	XSRFToken() <span class="keyword">string</span></span><br><span class="line">	CheckXSRFCookie() <span class="keyword">bool</span></span><br><span class="line">	HandlerFunc(fn <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">	URLMapping()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每一个通过<code>Router</code>函数注册的路由的<code>Controller</code>都需要实现<code>ControllerInterface</code>接口，一般开发人员自己写<code>Controller</code>的时候都是将<code>beego.Controller</code>（已经统一实现了所有的<code>ControllerInterface</code>接口，不过默认返回405/StatusMethodNotAllowed）内嵌进来，然后再自己实现自己的特有方法，例如我们1.2章节中的实现就是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SampleController <span class="keyword">struct</span> &#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><code>mappingMethods ...string</code>：变长入参，用来映射请求的动作（GET/POST/DELETE/…）和对应的处理方法函数，可以支持通过<code>;</code>隔开的方式映射不同的对应，如<code>&quot;get:Hello;list:Hello&quot;</code>，同时请求的动作可以通过<code>*</code>来匹配所有动作，如<code>&quot;*:Hello&quot;</code>。</li>
</ul>
<p>我们回到<code>Router</code>函数，这个函数中最终其实调用的是<code>BeeApp.Handlers.Add</code>，其中<code>BeeApp</code>是beego这个库中十分关键的一个全局变量，其中一个成员<code>Server</code>就是Go http库中的<code>http.Server</code>，另一个成员<code>Handlers</code>则实现了<code>http.Handler</code>接口，这也是<code>BeeApp</code>中最重要的一个成员。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/app.go</span></span><br><span class="line"><span class="keyword">package</span> beego</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// BeeApp is an application instance</span></span><br><span class="line">	BeeApp *App</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// create beego application</span></span><br><span class="line">	BeeApp = NewApp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App defines beego application with a new PatternServeMux.</span></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">	Handlers *ControllerRegister <span class="comment">//自定义Handler，实现了http.Handler接口，通过反射来实现不同路由调用对应的处理函数</span></span><br><span class="line">	Server   *http.Server   <span class="comment">// 实际的http server</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewApp returns a new beego application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span> *<span class="title">App</span></span> &#123;</span><br><span class="line">	cr := NewControllerRegister()</span><br><span class="line">	app := &amp;App&#123;Handlers: cr, Server: &amp;http.Server&#123;&#125;&#125;</span><br><span class="line">	<span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>App</code>的结构体中的成员可以料想到，注册完成后启动http server时，也一定是通过<code>BeeApp.Server</code>来启动server，这一点我们在下文中论证。</p>
<h5 id="2-1-2、ControllerRegister"><a href="#2-1-2、ControllerRegister" class="headerlink" title="2.1.2、ControllerRegister"></a>2.1.2、<code>ControllerRegister</code></h5><p><code>BeeApp.Handlers</code>其实是一个<code>ControllerRegister</code>，这是<code>beego</code>自己维护的一套路由映射规则，当程序启动时，通过<code>init()</code>函数注册的路由信息会全部保存到这里面，程序启动之后，当收到http请求时，处理函数会从中查询请求的URL对应的处理函数，然后调用这个函数来响应请求，这是<code>beego</code>的处理中枢。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/router.go</span></span><br><span class="line"><span class="comment">// ControllerRegister containers registered router rules, controller handlers and filters.</span></span><br><span class="line"><span class="keyword">type</span> ControllerRegister <span class="keyword">struct</span> &#123;</span><br><span class="line">	routers      <span class="keyword">map</span>[<span class="keyword">string</span>]*Tree  <span class="comment">// 路由表，key是http.method，value是实际的路由和函数组成的树结构</span></span><br><span class="line">	enablePolicy <span class="keyword">bool</span>    <span class="comment">// 是否开启policy</span></span><br><span class="line">	policies     <span class="keyword">map</span>[<span class="keyword">string</span>]*Tree</span><br><span class="line">	enableFilter <span class="keyword">bool</span>    <span class="comment">// 是否开启filter</span></span><br><span class="line">	filters      [FinishRouter + <span class="number">1</span>][]*FilterRouter<span class="comment">// 开启的filter表，主要包括BeforeStatic/BeforeRouter/BeforeExec/AfterExec/FinishRouter</span></span><br><span class="line">	pool         sync.Pool <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewControllerRegister returns a new ControllerRegister.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerRegister</span><span class="params">()</span> *<span class="title">ControllerRegister</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ControllerRegister&#123;</span><br><span class="line">		routers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Tree),</span><br><span class="line">		policies: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Tree),</span><br><span class="line">		pool: sync.Pool&#123;</span><br><span class="line">			New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">				<span class="keyword">return</span> beecontext.NewContext()</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add controller handler and pattern rules to ControllerRegister.</span></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="comment">//	default methods is the same name as method</span></span><br><span class="line"><span class="comment">//	Add("/user",&amp;UserController&#123;&#125;)</span></span><br><span class="line"><span class="comment">//	Add("/api/list",&amp;RestController&#123;&#125;,"*:ListFood")</span></span><br><span class="line"><span class="comment">//	Add("/api/create",&amp;RestController&#123;&#125;,"post:CreateFood")</span></span><br><span class="line"><span class="comment">//	Add("/api/update",&amp;RestController&#123;&#125;,"put:UpdateFood")</span></span><br><span class="line"><span class="comment">//	Add("/api/delete",&amp;RestController&#123;&#125;,"delete:DeleteFood")</span></span><br><span class="line"><span class="comment">//	Add("/api",&amp;RestController&#123;&#125;,"get,post:ApiFunc"</span></span><br><span class="line"><span class="comment">//	Add("/simple",&amp;SimpleController&#123;&#125;,"get:GetFunc;post:PostFunc")</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ControllerRegister)</span> <span class="title">Add</span><span class="params">(pattern <span class="keyword">string</span>, c ControllerInterface, mappingMethods ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.addWithMethodParams(pattern, c, <span class="literal">nil</span>, mappingMethods...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Router</code>函数调用的就是这里的<code>Add</code>，通过其注释可以看到支持的多种格式。</p>
<h5 id="2-1-3、addWithMethodParams"><a href="#2-1-3、addWithMethodParams" class="headerlink" title="2.1.3、addWithMethodParams"></a>2.1.3、<code>addWithMethodParams</code></h5><p><code>Router</code>函数最终调用的就是<code>ControllerRegister</code>的<code>addWithMethodParams</code>，这个函数对于理解<code>beego</code>的实现十分关键，在<code>Router</code>函数注册路由的时候，之所以只需要传入<code>Controller</code>的空实例，是因为在<code>addWithMethodParams</code>中通过反射已经获取了这个<code>Controller</code>的<code>Type</code>和<code>Value</code>，而<code>beego</code>中正是通过反射来真正实现路由的映射管理的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/router.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ControllerRegister)</span> <span class="title">addWithMethodParams</span><span class="params">(pattern <span class="keyword">string</span>, c ControllerInterface, methodParams []*param.MethodParam, mappingMethods ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	reflectVal := reflect.ValueOf(c)</span><br><span class="line">	t := reflect.Indirect(reflectVal).Type() <span class="comment">// 通过反射获取Controller的类型，后面接收请求时会 使用这个类型创建一个实例，并调用这个实例对应的方法</span></span><br><span class="line">	methods := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)  <span class="comment">// 请求类型和处理方法的映射，key是请求类型，如get，value是方法，如GetFunc</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(mappingMethods) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		semi := strings.Split(mappingMethods[<span class="number">0</span>], <span class="string">";"</span>) <span class="comment">// 分割映射对"get:GetFunc;post:PostFunc"</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> semi &#123;</span><br><span class="line">			colon := strings.Split(v, <span class="string">":"</span>)  <span class="comment">// 分割映射"get:GetFunc"</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(colon) != <span class="number">2</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"method mapping format is invalid"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			comma := strings.Split(colon[<span class="number">0</span>], <span class="string">","</span>)  <span class="comment">// 处理多对一的场景 "get,post:ApiFunc"</span></span><br><span class="line">			<span class="keyword">for</span> _, m := <span class="keyword">range</span> comma &#123;</span><br><span class="line">				<span class="keyword">if</span> m == <span class="string">"*"</span> || HTTPMETHOD[strings.ToUpper(m)] &#123; <span class="comment">// 处理全匹配的场景"*:ListFood"</span></span><br><span class="line">                    <span class="comment">// 通过反射查看当前这个Controller是否实现了对应的方法，如ListFood</span></span><br><span class="line">					<span class="keyword">if</span> val := reflectVal.MethodByName(colon[<span class="number">1</span>]); val.IsValid() &#123;</span><br><span class="line">						methods[strings.ToUpper(m)] = colon[<span class="number">1</span>]</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">panic</span>(<span class="string">"'"</span> + colon[<span class="number">1</span>] + <span class="string">"' method doesn't exist in the controller "</span> + t.Name())</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">panic</span>(v + <span class="string">" is an invalid method mapping. Method doesn't exist "</span> + m)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route := &amp;ControllerInfo&#123;&#125;  <span class="comment">// 用来保存某一个路由对应的所有信息，这个类型在2.1.3.1中会介绍</span></span><br><span class="line">	route.pattern = pattern</span><br><span class="line">	route.methods = methods  <span class="comment">// 支持的所有请求类型和对应的处理方法</span></span><br><span class="line">	route.routerType = routerTypeBeego</span><br><span class="line">	route.controllerType = t  <span class="comment">// 处理请求的Controller类型反射</span></span><br><span class="line">	route.initialize = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">ControllerInterface</span></span> &#123; <span class="comment">// 初始化函数</span></span><br><span class="line">		vc := reflect.New(route.controllerType) <span class="comment">// 通过反射创建一个Controller类型实例</span></span><br><span class="line">		execController, ok := vc.Interface().(ControllerInterface) <span class="comment">// 强制转换成接口</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"controller is not ControllerInterface"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后面这一段主要是将实例类型的方法赋予给execController</span></span><br><span class="line">		elemVal := reflect.ValueOf(c).Elem()</span><br><span class="line">		elemType := reflect.TypeOf(c).Elem()</span><br><span class="line">		execElem := reflect.ValueOf(execController).Elem()</span><br><span class="line"></span><br><span class="line">		numOfFields := elemVal.NumField()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfFields; i++ &#123;</span><br><span class="line">			fieldType := elemType.Field(i)</span><br><span class="line">			elemField := execElem.FieldByName(fieldType.Name)</span><br><span class="line">			<span class="keyword">if</span> elemField.CanSet() &#123;</span><br><span class="line">				fieldVal := elemVal.Field(i)</span><br><span class="line">				elemField.Set(fieldVal)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> execController</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route.methodParams = methodParams</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(methods) == <span class="number">0</span> &#123;  <span class="comment">// 对应于("/user",&amp;UserController&#123;&#125;)的场景，methods没有指定</span></span><br><span class="line">		<span class="keyword">for</span> m := <span class="keyword">range</span> HTTPMETHOD &#123;</span><br><span class="line">			p.addToRouter(m, pattern, route)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 对应于指定了method的场景</span></span><br><span class="line">		<span class="keyword">for</span> k := <span class="keyword">range</span> methods &#123;</span><br><span class="line">			<span class="keyword">if</span> k == <span class="string">"*"</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> m := <span class="keyword">range</span> HTTPMETHOD &#123;</span><br><span class="line">					p.addToRouter(m, pattern, route)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p.addToRouter(k, pattern, route)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终将路由和对应的处理方法进行映射使用的是<code>addToRouter</code>函数，其中主要是调用了<code>beego</code>中最关键的<code>Tree</code>来维护请求的URL与对应处理函数之间的关系，这个在2.1.3.2中会关键讲述。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/router.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ControllerRegister)</span> <span class="title">addToRouter</span><span class="params">(method, pattern <span class="keyword">string</span>, r *ControllerInfo)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class="line">		pattern = strings.ToLower(pattern)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 注意method是GET/PUT/PATCH/DELETE等http方法，pattern是请求的URL</span></span><br><span class="line">	<span class="keyword">if</span> t, ok := p.routers[method]; ok &#123;</span><br><span class="line">		t.AddRouter(pattern, r)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t := NewTree()</span><br><span class="line">		t.AddRouter(pattern, r)</span><br><span class="line">		p.routers[method] = t</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最终执行到了<code>t.AddRouter(pattern, r)</code>，这个在2.1.3.2节中继续往下探讨。</p>
<h6 id="2-1-3-1、ControllerInfo"><a href="#2-1-3-1、ControllerInfo" class="headerlink" title="2.1.3.1、ControllerInfo"></a>2.1.3.1、<code>ControllerInfo</code></h6><p>先来看一下<code>ControllerInfo</code>，在前面的代码中我们看到，注册路由时，将路由以及对应处理函数的Controller的反射类型都保存到了这里，这个类型中的所有成员如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ControllerInfo holds information about the controller.</span></span><br><span class="line"><span class="keyword">type</span> ControllerInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	pattern        <span class="keyword">string</span>   <span class="comment">// URL</span></span><br><span class="line">	controllerType reflect.Type  <span class="comment">// 注册这个URL对应的Controller的反射类型</span></span><br><span class="line">	methods        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 注册这个URL时的http方法与处理函数的映射，如"get:GetFunc;post:PostFunc"</span></span><br><span class="line">	handler        http.Handler  <span class="comment">// routerTypeHandler这种类型的路由对应的http.Handler，本质就是1.1中的例子</span></span><br><span class="line">	runFunction    FilterFunc <span class="comment">// 通过GET/PUT等（不是通过Router方式）注册路由时对应的过滤函数</span></span><br><span class="line">	routerType     <span class="keyword">int</span>  <span class="comment">// 注册的路由类型，包含routerTypeBeego/routerTypeRESTFul/routerTypeHandler</span></span><br><span class="line">	initialize     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">ControllerInterface</span> // 处理请求之前的初始化函数，主要对<span class="title">controllerType</span>进行实例化</span></span><br><span class="line">	methodParams   []*param.MethodParam <span class="comment">// 通过Auto方式注册路由时用来保存所有http请求参数的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>Tree</code>中保存的主要也是这个<code>ControllerInfo</code>。</p>
<h6 id="2-1-3-2、Tree"><a href="#2-1-3-2、Tree" class="headerlink" title="2.1.3.2、Tree"></a>2.1.3.2、<code>Tree</code></h6><blockquote>
<p>注意：在第一次读到Tree这里时，可以先跳过这一章节，将后面的内容都看完之后再回过头来看这部分内容。</p>
</blockquote>
<p><code>Tree</code>是beego中非常关键的一个维护请求路径和请求处理函数的一个类型，读懂了<code>Tree</code>，就基本能读懂beego的处理逻辑：</p>
<ul>
<li>在注册路由时，将路由按照<code>/</code>进行分割，然后通过树的方式保存对应的<code>ControllerInfo</code>，类似于字典树</li>
<li>在收到请求时，匹配路由时，通过搜索树的方式来找到对应的处理函数</li>
</ul>
<p>在了解<code>Tree</code>的处理逻辑之前，我们先来看一下beego支持的<a href="https://beego.me/docs/mvc/controller/router.md" target="_blank" rel="noopener">正则路由</a>规则：</p>
<ul>
<li><p><code>web.Router(“/api/?:id”, &amp;controllers.RController{})</code></p>
<p>默认匹配 //例如对于URL<code>/api/123</code>可以匹配成功，此时变量<code>:id</code>值为<code>123</code>，URL<code>/api/</code>可正常匹配</p>
</li>
<li><p><code>web.Router(“/api/:id”, &amp;controllers.RController{})</code></p>
<p>默认匹配 //例如对于URL<code>/api/123</code>可以匹配成功，此时变量<code>:id</code>值为<code>123</code>，但URL<code>/api/</code>匹配失败</p>
</li>
<li><p><code>web.Router(“/api/:id([0-9]+)“, &amp;controllers.RController{})</code></p>
<p>自定义正则匹配 //例如对于URL<code>/api/123</code>可以匹配成功，此时变量<code>:id</code>值为<code>123</code></p>
</li>
<li><p><code>web.Router(“/user/:username([\\w]+)“, &amp;controllers.RController{})</code></p>
<p>正则字符串匹配 //例如对于URL<code>/user/astaxie</code>可以匹配成功，此时变量<code>:username</code>值为<code>astaxie</code></p>
</li>
<li><p><code>web.Router(“/download/*.*”, &amp;controllers.RController{})</code></p>
<p>*匹配方式 //例如对于URL<code>/download/file/api.xml</code>可以匹配成功，此时变量<code>:path</code>值为<code>file/api</code>， <code>:ext</code>值为<code>xml</code></p>
</li>
<li><p><code>web.Router(“/download/ceshi/*“, &amp;controllers.RController{})</code></p>
<p>*全匹配方式 //例如对于URL<code>/download/ceshi/file/api.json</code>可以匹配成功，此时变量<code>:splat</code>值为<code>file/api.json</code></p>
</li>
<li><p><code>web.Router(“/:id:int”, &amp;controllers.RController{})</code></p>
<p>int 类型设置方式，匹配<code>:id</code>为<code>int</code> 类型，框架帮你实现了正则 <code>([0-9]+)</code></p>
</li>
<li><p><code>web.Router(“/:hi:string”, &amp;controllers.RController{})</code></p>
<p>string 类型设置方式，匹配<code>:hi</code> 为<code>string</code> 类型。框架帮你实现了正则 <code>([\w]+)</code></p>
</li>
<li><p><code>web.Router(“/cms_:id([0-9]+).html”, &amp;controllers.CmsController{})</code></p>
<p>带有前缀的自定义正则 //匹配 <code>:id</code> 为正则类型。匹配 <code>cms_123.html</code> 这样的 url <code>:id = 123</code></p>
</li>
</ul>
<p>可以在 Controller 中通过如下方式获取上面的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.Ctx.Input.Param(<span class="string">":id"</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">":username"</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">":splat"</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">":path"</span>)</span><br><span class="line">this.Ctx.Input.Param(<span class="string">":ext"</span>) <span class="comment">// 注意beego仅支持".json"、".xml"、".html"这3中后缀</span></span><br></pre></td></tr></table></figure>

<p>可以看到，注册路由时，<code>beego</code>的正则不仅支持<code>:id</code>、<code>:username</code>这种自定义变量从URL中取值的方式，还支持对这个自定义变量进行正则表达式<code>/api/:id([0-9]+)</code>或者数据类型的匹配<code>/:id:int</code>，设置还支持<code>/download/ceshi/*</code>和<code>/download/*.*</code>这种全匹配的方式，所以<code>Tree</code>中也需要分别对这些场景进行适配。我们直接来看一下<code>Tree</code>的数据结构便能一窥一二。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/tree.go</span></span><br><span class="line"><span class="comment">// Tree has three elements: FixRouter/wildcard/leaves</span></span><br><span class="line"><span class="comment">// fixRouter stores Fixed Router 固定路由</span></span><br><span class="line"><span class="comment">// wildcard stores params </span></span><br><span class="line"><span class="comment">// leaves store the endpoint information</span></span><br><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix <span class="keyword">string</span>  <span class="comment">// 路由前缀，仅在静态路由子节点时才会有值，根节点为空</span></span><br><span class="line">	fixrouters []*Tree  <span class="comment">// 子节点有静态路由时有值</span></span><br><span class="line">	wildcard *Tree  <span class="comment">// 子节点有正则时有值，查找时，如果找不到固定路由才会搜索这个</span></span><br><span class="line">	<span class="comment">//if set, failure to match wildcard search 匹配通配符搜索失败？</span></span><br><span class="line">	leaves []*leafInfo <span class="comment">// 用来保存当前节点的Controller信息，一般只有在叶子节点才会有值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> leafInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 当前这个叶子节点倒根节点的所有通配符. eg, ["id" "name"] for the wildcard ":id" and ":name"</span></span><br><span class="line">	wildcards []<span class="keyword">string</span></span><br><span class="line">	regexps *regexp.Regexp  <span class="comment">// 从跟节点到当前叶子的第一个正则开始对应的正则表达式</span></span><br><span class="line">	runObject <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 其实承载的是前面的&amp;ControllerInfo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Tree</code>这个类型有两个最关键的方法：</p>
<ul>
<li>一个是<code>AddRouter</code>，目的是根据注册的URL将对应的<code>ControllerInfo</code>高效地保存到树中，以下是主要代码的分析</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/tree.go</span></span><br><span class="line"><span class="comment">// 注册路由时最终保存URL与对应ControllerInfo的方法，注意runObject传进来的就是&amp;ControllerInfo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">AddRouter</span><span class="params">(pattern <span class="keyword">string</span>, runObject <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里的splitPath将URL进行strings.Split(pattern, "/")处理，返回各级字符串的slice</span></span><br><span class="line">	t.addseg(splitPath(pattern), runObject, <span class="literal">nil</span>, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "/"</span></span><br><span class="line"><span class="comment">// "admin" -&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">addseg</span><span class="params">(segments []<span class="keyword">string</span>, route <span class="keyword">interface</span>&#123;&#125;, wildcards []<span class="keyword">string</span>, reg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(segments) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 1、已经到达叶子，则直接将这个ControllerInfo作为子节点加入到这个父节点的子节点中</span></span><br><span class="line">		<span class="keyword">if</span> reg != <span class="string">""</span> &#123;</span><br><span class="line">			t.leaves = <span class="built_in">append</span>(t.leaves, &amp;leafInfo&#123;runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(<span class="string">"^"</span> + reg + <span class="string">"$"</span>)&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// </span></span><br><span class="line">			t.leaves = <span class="built_in">append</span>(t.leaves, &amp;leafInfo&#123;runObject: route, wildcards: wildcards&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2、还未到达叶子，则处理剩余URL中最前面这个字符串</span></span><br><span class="line">		seg := segments[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// iswild表示有没有:id或者*这种特殊的匹配符，也就是当前是否是正则路由</span></span><br><span class="line">        <span class="comment">// param返回的是正则中的变量，如":id"、":splat"、":path"、":ext"这种</span></span><br><span class="line">        <span class="comment">// regexpStr返回的则是匹配这个变量的正则表达式</span></span><br><span class="line">		iswild, params, regexpStr := splitSegment(seg) <span class="comment">// 这个函数的代码其实也挺关键的，但是考虑篇幅就不写了</span></span><br><span class="line">		<span class="comment">// “?:id”这种格式，说明当前节点可以为空，把这种情况也算在内</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(params) &gt; <span class="number">0</span> &amp;&amp; params[<span class="number">0</span>] == <span class="string">":"</span> &#123;</span><br><span class="line">			t.addseg(segments[<span class="number">1</span>:], route, wildcards, reg)</span><br><span class="line">            params = params[<span class="number">1</span>:]  <span class="comment">// 把":"去掉</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Rule: /login/*/access match /login/2009/11/access</span></span><br><span class="line">		<span class="comment">//if already has *, and when loop the access, should as a regexpStr</span></span><br><span class="line">        <span class="comment">// a：如果前面的路由中已经有*了，那么即使当前是静态路由，也需要设置成正则路由，并且需要在正则表达式中增加当前字符串</span></span><br><span class="line">		<span class="keyword">if</span> !iswild &amp;&amp; utils.InSlice(<span class="string">":splat"</span>, wildcards) &#123;</span><br><span class="line">			iswild = <span class="literal">true</span></span><br><span class="line">			regexpStr = seg</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Rule: /user/:id/*</span></span><br><span class="line">        <span class="comment">// b：如果当前是第一个*，并且前面也有正则</span></span><br><span class="line">		<span class="keyword">if</span> seg == <span class="string">"*"</span> &amp;&amp; <span class="built_in">len</span>(wildcards) &gt; <span class="number">0</span> &amp;&amp; reg == <span class="string">""</span> &#123;</span><br><span class="line">			regexpStr = <span class="string">"(.+)"</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> iswild &#123;</span><br><span class="line">            <span class="comment">// 2.1、当前节点是正则路由的情况下</span></span><br><span class="line">			<span class="keyword">if</span> t.wildcard == <span class="literal">nil</span> &#123;</span><br><span class="line">				t.wildcard = NewTree()  <span class="comment">// 正则路由子节点</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span> regexpStr != <span class="string">""</span> &#123; <span class="comment">// ":id:int"、":id([0-9]+"或者前面的a/b这两种情况</span></span><br><span class="line">				<span class="keyword">if</span> reg == <span class="string">""</span> &#123; <span class="comment">// 这是URL中第一个带有正则表达式的字符串</span></span><br><span class="line">					rr := <span class="string">""</span></span><br><span class="line">					<span class="keyword">for</span> _, w := <span class="keyword">range</span> wildcards &#123;</span><br><span class="line">						<span class="keyword">if</span> w == <span class="string">":splat"</span> &#123;</span><br><span class="line">							rr = rr + <span class="string">"(.+)/"</span></span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							rr = rr + <span class="string">"([^/]+)/"</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					regexpStr = rr + regexpStr</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					regexpStr = <span class="string">"/"</span> + regexpStr</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> reg != <span class="string">""</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> seg == <span class="string">"*.*"</span> &#123;</span><br><span class="line">					regexpStr = <span class="string">"/([^.]+).(.+)"</span></span><br><span class="line">					params = params[<span class="number">1</span>:] <span class="comment">// "*.*"的params是[. :path :ext]，因此去掉.这个分隔符</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> <span class="keyword">range</span> params &#123;</span><br><span class="line">						regexpStr = <span class="string">"/([^/]+)"</span> + regexpStr</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> seg == <span class="string">"*.*"</span> &#123;</span><br><span class="line">					params = params[<span class="number">1</span>:]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			t.wildcard.addseg(segments[<span class="number">1</span>:], route, <span class="built_in">append</span>(wildcards, params...), reg+regexpStr)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2、当前节点是固定路由的场景下，先查看有没有已经存在的同名固定路由的子节点，没有则创建</span></span><br><span class="line">            <span class="comment">// 需要注意的是，Tree中的prefix就是用来保存这个固定路由的字符串</span></span><br><span class="line">			<span class="keyword">var</span> subTree *Tree</span><br><span class="line">			<span class="keyword">for</span> _, sub := <span class="keyword">range</span> t.fixrouters &#123;</span><br><span class="line">				<span class="keyword">if</span> sub.prefix == seg &#123;</span><br><span class="line">					subTree = sub</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> subTree == <span class="literal">nil</span> &#123;</span><br><span class="line">				subTree = NewTree()</span><br><span class="line">				subTree.prefix = seg <span class="comment">// 创建的新Tree以当前这个seg作为前缀</span></span><br><span class="line">				t.fixrouters = <span class="built_in">append</span>(t.fixrouters, subTree) <span class="comment">// 将这个子节点加入到固定路由列表中</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 在子节点中递归处理后面的路由规则，前面的通配符和正则表达式都会继续后传递</span></span><br><span class="line">			subTree.addseg(segments[<span class="number">1</span>:], route, wildcards, reg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一个是<code>Match</code>，也就是根据请求的URL找到对应的<code>ControllerInfo</code>信息，以下是主要代码的分析</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match router to runObject &amp; params</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">Match</span><span class="params">(pattern <span class="keyword">string</span>, ctx *context.Context)</span> <span class="params">(runObject <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span> || pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 用来保存URL中正则对应的值，例如":id"、":splat"等对应的实际值</span></span><br><span class="line">	w := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">return</span> t.match(pattern[<span class="number">1</span>:], pattern, w, ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pattern用于记录剩余的URL，treePattern用于记录需要正则匹配的URL部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">match</span><span class="params">(treePattern <span class="keyword">string</span>, pattern <span class="keyword">string</span>, wildcardValues []<span class="keyword">string</span>, ctx *context.Context)</span> <span class="params">(runObject <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 去掉最前面的'/'</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pattern) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(pattern) &amp;&amp; pattern[i] == <span class="string">'/'</span>; i++ &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		pattern = pattern[i:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// URL已经匹配完成，先看leaves中是否有匹配的，然后在看正则的子节点中是否有匹配的</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, l := <span class="keyword">range</span> t.leaves &#123;</span><br><span class="line">			<span class="keyword">if</span> ok := l.match(treePattern, wildcardValues, ctx); ok &#123;</span><br><span class="line">				<span class="keyword">return</span> l.runObject</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> t.wildcard != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, l := <span class="keyword">range</span> t.wildcard.leaves &#123;</span><br><span class="line">				<span class="keyword">if</span> ok := l.match(treePattern, wildcardValues, ctx); ok &#123;</span><br><span class="line">					<span class="keyword">return</span> l.runObject</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 取出当前URL的第一截</span></span><br><span class="line">	<span class="keyword">var</span> seg <span class="keyword">string</span></span><br><span class="line">	i, l := <span class="number">0</span>, <span class="built_in">len</span>(pattern)</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; l &amp;&amp; pattern[i] != <span class="string">'/'</span>; i++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">		seg = pattern</span><br><span class="line">		pattern = <span class="string">""</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		seg = pattern[:i]</span><br><span class="line">		pattern = pattern[i:]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 1、先查到固定路由的子节点的prefix中是否匹配当前这一截，注意由于这里是固定路由，treePattern需要去掉当前的prefix</span></span><br><span class="line">	<span class="keyword">for</span> _, subTree := <span class="keyword">range</span> t.fixrouters &#123;</span><br><span class="line">		<span class="keyword">if</span> subTree.prefix == seg &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(pattern) != <span class="number">0</span> &amp;&amp; pattern[<span class="number">0</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">				treePattern = pattern[<span class="number">1</span>:]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				treePattern = pattern</span><br><span class="line">			&#125;</span><br><span class="line">			runObject = subTree.match(treePattern, pattern, wildcardValues, ctx)</span><br><span class="line">			<span class="keyword">if</span> runObject != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> runObject == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(t.fixrouters) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Filter the .json .xml .html extension</span></span><br><span class="line">		<span class="keyword">for</span> _, str := <span class="keyword">range</span> allowSuffixExt &#123;</span><br><span class="line">			<span class="keyword">if</span> strings.HasSuffix(seg, str) &#123;</span><br><span class="line">				<span class="keyword">for</span> _, subTree := <span class="keyword">range</span> t.fixrouters &#123;</span><br><span class="line">					<span class="keyword">if</span> subTree.prefix == seg[:<span class="built_in">len</span>(seg)-<span class="built_in">len</span>(str)] &#123;</span><br><span class="line">						runObject = subTree.match(treePattern, pattern, wildcardValues, ctx)</span><br><span class="line">						<span class="keyword">if</span> runObject != <span class="literal">nil</span> &#123;</span><br><span class="line">							ctx.Input.SetParam(<span class="string">":ext"</span>, str[<span class="number">1</span>:])</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 2、然后查找正则的子节点中是否有匹配的</span></span><br><span class="line">	<span class="keyword">if</span> runObject == <span class="literal">nil</span> &amp;&amp; t.wildcard != <span class="literal">nil</span> &#123;</span><br><span class="line">		runObject = t.wildcard.match(treePattern, pattern, <span class="built_in">append</span>(wildcardValues, seg), ctx)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3、最后查找叶子中是否有匹配的</span></span><br><span class="line">	<span class="keyword">if</span> runObject == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(t.leaves) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		wildcardValues = <span class="built_in">append</span>(wildcardValues, seg)</span><br><span class="line">		start, i := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(pattern); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> pattern[i] == <span class="string">'/'</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; start &lt; <span class="built_in">len</span>(pattern) &#123;</span><br><span class="line">					wildcardValues = <span class="built_in">append</span>(wildcardValues, pattern[start:i])</span><br><span class="line">				&#125;</span><br><span class="line">				start = i + <span class="number">1</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> start &gt; <span class="number">0</span> &#123;</span><br><span class="line">			wildcardValues = <span class="built_in">append</span>(wildcardValues, pattern[start:i])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, l := <span class="keyword">range</span> t.leaves &#123;</span><br><span class="line">			<span class="keyword">if</span> ok := l.match(treePattern, wildcardValues, ctx); ok &#123;</span><br><span class="line">				<span class="keyword">return</span> l.runObject</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> runObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上有一点没有体现出来的是，在<code>t.leaves</code>中执行match时，对于URL中的实际值会设置到ctx中的param中，这也是为什么入参中一定要传入ctx。</p>
<h4 id="2-2、启动server"><a href="#2-2、启动server" class="headerlink" title="2.2、启动server"></a>2.2、启动server</h4><p>在1.2章节的例子中，在<code>init()</code>中注册完路由之后，<code>main</code>函数会调用<code>beego.Run()</code>来启动这个http server，接下来我们就一起看一下实际是如何启动的。</p>
<h5 id="2-2-1、Run方法"><a href="#2-2-1、Run方法" class="headerlink" title="2.2.1、Run方法"></a>2.2.1、<code>Run</code>方法</h5><p><code>beego.Run()</code>这个方法是一个拥有变长入参的函数，可以在入参中输入字符串用来设置server的监听ip和端口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/beego.go</span></span><br><span class="line"><span class="comment">// Run beego application.</span></span><br><span class="line"><span class="comment">// beego.Run() default run on HttpPort</span></span><br><span class="line"><span class="comment">// beego.Run("localhost")</span></span><br><span class="line"><span class="comment">// beego.Run(":8089")</span></span><br><span class="line"><span class="comment">// beego.Run("127.0.0.1:8089")</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(params ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	initBeforeHTTPRun() <span class="comment">// http server的初始化注册，如设置默认处理handler等</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中间代码略，主要根据params配置server的监听ip和端口</span></span><br><span class="line"></span><br><span class="line">	BeeApp.Run() <span class="comment">// 实际的运行函数，这个也就是2.1.1中的App类型的方法，前面讲过APP中有http.Server和自己的Handler成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Run beego application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *App)</span> <span class="title">Run</span><span class="params">(mws ...MiddleWare)</span></span> &#123;</span><br><span class="line">	addr := BConfig.Listen.HTTPAddr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> BConfig.Listen.HTTPPort != <span class="number">0</span> &#123;</span><br><span class="line">		addr = fmt.Sprintf(<span class="string">"%s:%d"</span>, BConfig.Listen.HTTPAddr, BConfig.Listen.HTTPPort)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		err        error</span><br><span class="line">		l          net.Listener</span><br><span class="line">		endRunning = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run cgi server</span></span><br><span class="line">	<span class="comment">// 启动cgi服务器的代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键逻辑：将自己的Handler（也就是ControllerRegister）赋予给http.Server.Handler，注意http.Server.Handler是一个interface（即ServeHTTP(ResponseWriter, *Request)）</span></span><br><span class="line">	app.Server.Handler = app.Handlers</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(mws) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> mws[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		app.Server.Handler = mws[i](app.Server.Handler)</span><br><span class="line">	&#125;</span><br><span class="line">	app.Server.ReadTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</span><br><span class="line">	app.Server.WriteTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</span><br><span class="line">	app.Server.ErrorLog = logs.GetLogger(<span class="string">"HTTP"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run graceful mode</span></span><br><span class="line">	<span class="comment">// graceful mode代码略，默认情况下不开，本文也不仔细研究</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// run normal mode</span></span><br><span class="line">	<span class="comment">// 启动https安全端口代码略</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 考虑到篇幅有限，这里只讨论http这种方式，https的方式只是在证书处理上有区别</span></span><br><span class="line">	<span class="keyword">if</span> BConfig.Listen.EnableHTTP &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 启动一个协程来启动server</span></span><br><span class="line">			app.Server.Addr = addr</span><br><span class="line">			logs.Info(<span class="string">"http server Running on http://%s"</span>, app.Server.Addr)</span><br><span class="line">			<span class="keyword">if</span> BConfig.Listen.ListenTCP4 &#123;</span><br><span class="line">				ln, err := net.Listen(<span class="string">"tcp4"</span>, app.Server.Addr)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					logs.Critical(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">					time.Sleep(<span class="number">100</span> * time.Microsecond)</span><br><span class="line">					endRunning &lt;- <span class="literal">true</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 关键逻辑：实际就是调用</span></span><br><span class="line">				<span class="keyword">if</span> err = app.Server.Serve(ln); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					logs.Critical(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">					time.Sleep(<span class="number">100</span> * time.Microsecond)</span><br><span class="line">					endRunning &lt;- <span class="literal">true</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := app.Server.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					logs.Critical(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">					time.Sleep(<span class="number">100</span> * time.Microsecond)</span><br><span class="line">					endRunning &lt;- <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-endRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述逻辑中，最关键的点在这一行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.Server.Handler = app.Handlers</span><br></pre></td></tr></table></figure>

<p>我们知道，<code>app.Server.Handler</code>其实是Go官方http库中的关键interface，因此<code>app.Handlers</code>（实际是<code>ControllerRegister</code>）实现的这个方法就是实际处理请求对应的Handler了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/net/http/server.go</span></span><br><span class="line"><span class="comment">// A Handler responds to an HTTP request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ServeHTTP should write reply headers and data to the ResponseWriter</span></span><br><span class="line"><span class="comment">// and then return. Returning signals that the request is finished; it</span></span><br><span class="line"><span class="comment">// is not valid to use the ResponseWriter or read from the</span></span><br><span class="line"><span class="comment">// Request.Body after or concurrently with the completion of the</span></span><br><span class="line"><span class="comment">// ServeHTTP call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Depending on the HTTP client software, HTTP protocol version, and</span></span><br><span class="line"><span class="comment">// any intermediaries between the client and the Go server, it may not</span></span><br><span class="line"><span class="comment">// be possible to read from the Request.Body after writing to the</span></span><br><span class="line"><span class="comment">// ResponseWriter. Cautious handlers should read the Request.Body</span></span><br><span class="line"><span class="comment">// first, and then reply.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Except for reading the body, handlers should not modify the</span></span><br><span class="line"><span class="comment">// provided Request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</span></span><br><span class="line"><span class="comment">// that the effect of the panic was isolated to the active request.</span></span><br><span class="line"><span class="comment">// It recovers the panic, logs a stack trace to the server error log,</span></span><br><span class="line"><span class="comment">// and either closes the network connection or sends an HTTP/2</span></span><br><span class="line"><span class="comment">// RST_STREAM, depending on the HTTP protocol. To abort a handler so</span></span><br><span class="line"><span class="comment">// the client sees an interrupted response but the server doesn't log</span></span><br><span class="line"><span class="comment">// an error, panic with the value ErrAbortHandler.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-2、ControllerRegister的http-Handler"><a href="#2-2-2、ControllerRegister的http-Handler" class="headerlink" title="2.2.2、ControllerRegister的http.Handler"></a>2.2.2、<code>ControllerRegister</code>的<code>http.Handler</code></h5><p>最终我们定位到<code>beego</code>启动的server的处理逻辑如下：</p>
<ul>
<li>根据请求从<code>ControllerRegister</code>的<code>Tree</code>中搜索对应的<code>ControllerInfo</code></li>
<li>根据<code>ControllerInfo</code>中记录的Controller的反射信息创建对应的实例</li>
<li>执行这个Controller实例的Init/Prepare等前置方法，然后直接注册的功能方法，最后执行Finish等后置方法</li>
</ul>
<p>详细的代码分析可以参考（部分非关键逻辑已经省略）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/router.go</span></span><br><span class="line"><span class="comment">// Implement http.Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ControllerRegister)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		runRouter    reflect.Type  <span class="comment">// Controller的类型反射</span></span><br><span class="line">		findRouter   <span class="keyword">bool</span>          <span class="comment">// 是否是注册过的路由</span></span><br><span class="line">		runMethod    <span class="keyword">string</span>        <span class="comment">// 改请求对应的Controller实例的方法</span></span><br><span class="line">		methodParams []*param.MethodParam</span><br><span class="line">		routerInfo   *ControllerInfo</span><br><span class="line">		isRunnable   <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line">	context := p.GetContext()</span><br><span class="line"></span><br><span class="line">	context.Reset(rw, r)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> p.GiveBackContext(context)</span><br><span class="line">	<span class="keyword">if</span> BConfig.RecoverFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> BConfig.RecoverFunc(context)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	context.Output.EnableGzip = BConfig.EnableGzip</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> BConfig.RunMode == DEV &#123;</span><br><span class="line">		context.Output.Header(<span class="string">"Server"</span>, BConfig.ServerName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> urlPath = r.URL.Path</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class="line">		urlPath = strings.ToLower(urlPath)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// filter wrong http method</span></span><br><span class="line">	<span class="keyword">if</span> !HTTPMETHOD[r.Method] &#123;</span><br><span class="line">		exception(<span class="string">"405"</span>, context)</span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// filter for static file</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.filters[BeforeStatic]) &gt; <span class="number">0</span> &amp;&amp; p.execFilter(context, urlPath, BeforeStatic) &#123;</span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	serverStaticRouter(context)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> context.ResponseWriter.Started &#123;</span><br><span class="line">		findRouter = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodGet &amp;&amp; r.Method != http.MethodHead &#123;</span><br><span class="line">		<span class="keyword">if</span> BConfig.CopyRequestBody &amp;&amp; !context.Input.IsUpload() &#123;</span><br><span class="line">			context.Input.CopyBody(BConfig.MaxMemory)</span><br><span class="line">		&#125;</span><br><span class="line">		context.Input.ParseFormOrMulitForm(BConfig.MaxMemory)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// session init</span></span><br><span class="line">	<span class="keyword">if</span> BConfig.WebConfig.Session.SessionOn &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		context.Input.CruSession, err = GlobalSessions.SessionStart(rw, r)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logs.Error(err)</span><br><span class="line">			exception(<span class="string">"503"</span>, context)</span><br><span class="line">			<span class="keyword">goto</span> Admin</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> context.Input.CruSession != <span class="literal">nil</span> &#123;</span><br><span class="line">				context.Input.CruSession.SessionRelease(rw)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.filters[BeforeRouter]) &gt; <span class="number">0</span> &amp;&amp; p.execFilter(context, urlPath, BeforeRouter) &#123;</span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// User can define RunController and RunMethod in filter</span></span><br><span class="line">	<span class="keyword">if</span> context.Input.RunController != <span class="literal">nil</span> &amp;&amp; context.Input.RunMethod != <span class="string">""</span> &#123;</span><br><span class="line">		findRouter = <span class="literal">true</span></span><br><span class="line">		runMethod = context.Input.RunMethod</span><br><span class="line">		runRouter = context.Input.RunController</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关键逻辑，找到改请求对应的ControllerInfo，在这个过程中也会把":id"、":splat"等值写入到ctx的params中</span></span><br><span class="line">		routerInfo, findRouter = p.FindRouter(context)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if no matches to url, throw a not found exception</span></span><br><span class="line">	<span class="keyword">if</span> !findRouter &#123;</span><br><span class="line">		exception(<span class="string">"404"</span>, context)</span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> splat := context.Input.Param(<span class="string">":splat"</span>); splat != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> strings.Split(splat, <span class="string">"/"</span>) &#123;</span><br><span class="line">			context.Input.SetParam(strconv.Itoa(k), v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> routerInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// store router pattern into context</span></span><br><span class="line">		context.Input.SetData(<span class="string">"RouterPattern"</span>, routerInfo.pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// execute middleware filters</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.filters[BeforeExec]) &gt; <span class="number">0</span> &amp;&amp; p.execFilter(context, urlPath, BeforeExec) &#123;</span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check policies</span></span><br><span class="line">	<span class="keyword">if</span> p.execPolicy(context, urlPath) &#123;</span><br><span class="line">		<span class="keyword">goto</span> Admin</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> routerInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> routerInfo.routerType == routerTypeRESTFul &#123;</span><br><span class="line">            <span class="comment">// routerTypeRESTFul：AddMethod()的方式注册的路由</span></span><br><span class="line">			<span class="keyword">if</span> _, ok := routerInfo.methods[r.Method]; ok &#123;</span><br><span class="line">				isRunnable = <span class="literal">true</span></span><br><span class="line">				routerInfo.runFunction(context)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				exception(<span class="string">"405"</span>, context)</span><br><span class="line">				<span class="keyword">goto</span> Admin</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> routerInfo.routerType == routerTypeHandler &#123;</span><br><span class="line">            <span class="comment">// routerTypeHandler：Handler()的方式注册的路由</span></span><br><span class="line">			isRunnable = <span class="literal">true</span></span><br><span class="line">			routerInfo.handler.ServeHTTP(context.ResponseWriter, context.Request)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// routerTypeBeego：Add()或者AddAuto()的方式注册的路由，前者就是2.1节中的方式</span></span><br><span class="line">			runRouter = routerInfo.controllerType</span><br><span class="line">			methodParams = routerInfo.methodParams</span><br><span class="line">			method := r.Method</span><br><span class="line">			<span class="keyword">if</span> r.Method == http.MethodPost &amp;&amp; context.Input.Query(<span class="string">"_method"</span>) == http.MethodPut &#123;</span><br><span class="line">				method = http.MethodPut</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> r.Method == http.MethodPost &amp;&amp; context.Input.Query(<span class="string">"_method"</span>) == http.MethodDelete &#123;</span><br><span class="line">				method = http.MethodDelete</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> m, ok := routerInfo.methods[method]; ok &#123;</span><br><span class="line">				runMethod = m</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> m, ok = routerInfo.methods[<span class="string">"*"</span>]; ok &#123;</span><br><span class="line">				runMethod = m</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				runMethod = method</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// also defined runRouter &amp; runMethod from filter</span></span><br><span class="line">	<span class="keyword">if</span> !isRunnable &#123;</span><br><span class="line">		<span class="comment">// Invoke the request handler</span></span><br><span class="line">		<span class="keyword">var</span> execController ControllerInterface</span><br><span class="line">		<span class="keyword">if</span> routerInfo != <span class="literal">nil</span> &amp;&amp; routerInfo.initialize != <span class="literal">nil</span> &#123;</span><br><span class="line">			execController = routerInfo.initialize()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 关键逻辑：实例化一个Controller，如1.2样例中的SampleController</span></span><br><span class="line">			vc := reflect.New(runRouter)</span><br><span class="line">			<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">			execController, ok = vc.Interface().(ControllerInterface)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"controller is not ControllerInterface"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用实例的Init方法</span></span><br><span class="line">		execController.Init(context, runRouter.Name(), runMethod, execController)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用实例的Prepare方法</span></span><br><span class="line">		execController.Prepare()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用XSRF方法略 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// URLMapping</span></span><br><span class="line">		execController.URLMapping()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !context.ResponseWriter.Started &#123;</span><br><span class="line">			<span class="comment">// exec main logic</span></span><br><span class="line">			<span class="keyword">switch</span> runMethod &#123;</span><br><span class="line">			<span class="keyword">case</span> http.MethodGet:</span><br><span class="line">				execController.Get()</span><br><span class="line">			<span class="keyword">case</span> http.MethodPost:</span><br><span class="line">				execController.Post()</span><br><span class="line">			<span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">				execController.Delete()</span><br><span class="line">			<span class="keyword">case</span> http.MethodPut:</span><br><span class="line">				execController.Put()</span><br><span class="line">			<span class="keyword">case</span> http.MethodHead:</span><br><span class="line">				execController.Head()</span><br><span class="line">			<span class="keyword">case</span> http.MethodPatch:</span><br><span class="line">				execController.Patch()</span><br><span class="line">			<span class="keyword">case</span> http.MethodOptions:</span><br><span class="line">				execController.Options()</span><br><span class="line">			<span class="keyword">case</span> http.MethodTrace:</span><br><span class="line">				execController.Trace()</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> !execController.HandlerFunc(runMethod) &#123;</span><br><span class="line">					vc := reflect.ValueOf(execController)</span><br><span class="line">                    <span class="comment">// 根据之前注册的Controller的函数名找到对应的方法</span></span><br><span class="line">					method := vc.MethodByName(runMethod)</span><br><span class="line">					in := param.ConvertParams(methodParams, method.Type(), context)</span><br><span class="line">                    <span class="comment">// 关键逻辑，调用注册的方法，如1.2中的Hello()</span></span><br><span class="line">					out := method.Call(in)</span><br><span class="line"></span><br><span class="line">					<span class="comment">// For backward compatibility we only handle response if we had incoming methodParams</span></span><br><span class="line">					<span class="keyword">if</span> methodParams != <span class="literal">nil</span> &#123;</span><br><span class="line">						p.handleParamResponse(context, execController, out)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// render template</span></span><br><span class="line">			<span class="keyword">if</span> !context.ResponseWriter.Started &amp;&amp; context.Output.Status == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> BConfig.WebConfig.AutoRender &#123;</span><br><span class="line">					<span class="keyword">if</span> err := execController.Render(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						logs.Error(err)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用实例的Finish方法</span></span><br><span class="line">		execController.Finish()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行中间件的filter函数</span></span><br><span class="line"></span><br><span class="line">Admin:</span><br><span class="line">	<span class="comment">// 统计QPS数据，代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-3、FindRouter"><a href="#2-2-3、FindRouter" class="headerlink" title="2.2.3、FindRouter"></a>2.2.3、<code>FindRouter</code></h5><p>2.2.2中有一步是查找是否存在这个URL对应的处理方法，对应的代码比较简单，主要就是调用<code>Tree</code>的Match方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor/github.com/astaxie/beego/router.go</span></span><br><span class="line"><span class="comment">// FindRouter Find Router info for URL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ControllerRegister)</span> <span class="title">FindRouter</span><span class="params">(context *beecontext.Context)</span> <span class="params">(routerInfo *ControllerInfo, isFind <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> urlPath = context.Input.URL()</span><br><span class="line">	<span class="keyword">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class="line">		urlPath = strings.ToLower(urlPath)</span><br><span class="line">	&#125;</span><br><span class="line">	httpMethod := context.Input.Method()</span><br><span class="line">	<span class="keyword">if</span> t, ok := p.routers[httpMethod]; ok &#123;</span><br><span class="line">        <span class="comment">// 这里实际就去执行2.1.3.2中Tree的Match方法</span></span><br><span class="line">		runObject := t.Match(urlPath, context)</span><br><span class="line">		<span class="keyword">if</span> r, ok := runObject.(*ControllerInfo); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> r, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>通过案例与<code>beego</code>源码的解析，可以看出，<code>beego</code>这个http框架的核心在于充分使用Go语言的反射机制来进行抽象，通过<code>Tree</code>来对注册的路由进行保存和匹配，同时提供一个基本的<code>Controller</code>类型提供给开发者进行内嵌，开发者只需要实现自己的处理方法然后在初始化时进行注册即可。</p>
<h3 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h3><p><a href="https://juejin.cn/post/6844903559335526407" target="_blank" rel="noopener">Golang的反射reflect深入理解和示例</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/" target="_blank" rel="noopener">Go 语言反射的实现原理</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>yost
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yost.top/2021/01/08/beego-code-review/" title="beego代码分析">http://yost.top/2021/01/08/beego-code-review/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/beego/" rel="tag"># beego</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/04/volcano-code-review/" rel="prev" title="volcano代码分析">
      <i class="fa fa-chevron-left"></i> volcano代码分析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、-前言"><span class="nav-text">1、 前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1、使用http库实现"><span class="nav-text">1.1、使用http库实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2、使用beego来实现"><span class="nav-text">1.2、使用beego来实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、代码剖析"><span class="nav-text">2、代码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1、注册路由"><span class="nav-text">2.1、注册路由</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1、Router函数"><span class="nav-text">2.1.1、Router函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2、ControllerRegister"><span class="nav-text">2.1.2、ControllerRegister</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3、addWithMethodParams"><span class="nav-text">2.1.3、addWithMethodParams</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-1、ControllerInfo"><span class="nav-text">2.1.3.1、ControllerInfo</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-2、Tree"><span class="nav-text">2.1.3.2、Tree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2、启动server"><span class="nav-text">2.2、启动server</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1、Run方法"><span class="nav-text">2.2.1、Run方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2、ControllerRegister的http-Handler"><span class="nav-text">2.2.2、ControllerRegister的http.Handler</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3、FindRouter"><span class="nav-text">2.2.3、FindRouter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、总结"><span class="nav-text">3、总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、参考"><span class="nav-text">4、参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yost</p>
  <div class="site-description" itemprop="description">种一棵树最好的时间是十年前，其次是现在~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yost</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='50' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
